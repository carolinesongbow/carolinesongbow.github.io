[{"content":"@Component @Configuration public class MyConfig { public MyConfig(AbstractEnvirionment environment) { for (PropertySource instanceof OriginTrackedMapPropertySource \u0026amp;\u0026amp; propertySource.getName().contains(\u0026#34;.properties\u0026#34;)) { OriginTrackedMapPropertySource source = (OriginTrackedMapPropertySource) propertySource; for (Map.Entry\u0026lt;String, Object\u0026gt; entry : source.getSource().entrySet()) { System.out.println(entry.getKey() + \u0026#34;:\u0026#34; + entry.getValue()); } } } } 记录一下，之后研究。\n","date":"2021-11-04T11:11:54+08:00","permalink":"/post/2021-11-04-springboot%E8%AF%BB%E5%8F%96%E9%85%8D%E7%BD%AE%E7%9A%84%E5%8F%A6%E5%A4%96%E4%B8%80%E7%A7%8D%E6%96%B9%E6%B3%95/","title":"Springboot读取配置的另外一种方法"},{"content":"背景 项目中提供数据源连接服务，使用了相当多 JDBC 驱动插件，其中包含 MySQL 5.1.44 版本驱动和 MariaDB 2.2.3 版本驱动。\n问题 有一个用户使用了较低版本的 Mycat，在连接数据源时，长时间连接不上。\n排查 JDBC 的 DriverManager 在连接时，会自动尝试所有的驱动的连接（是的，没错，没法指定驱动连接，狗日的）。在本例中，当遍历至 MariaDB 的驱动时，在接收包的时候遇到版本不兼容问题（低版本 Mycat 数据库和高版本 MariaDB 驱动），DEBUG 调试发现，在读取数据库服务器返回的一个流时卡死。卡死原因不明。大致是数据库与驱动版本不兼容问题导致。\n解决 一开始想尝试用注销再注册的方式把 MariaDB 的驱动放在 DriverManager 静态驱动列表的最尾，防止这一类 MySQL 数据源尝试用 MariaDB 驱动去连接以避免卡死问题。\n尝试过程中追踪 MariaDB 驱动源码发现：\npublic static boolean acceptsUrl(String url) { return (url != null) \u0026amp;\u0026amp; (url.startsWith(\u0026#34;jdbc:mariadb:\u0026#34;) || (url.startsWith(\u0026#34;jdbc:mysql:\u0026#34;) \u0026amp;\u0026amp; !url.contains(DISABLE_MYSQL_URL))); } private static final String DISABLE_MYSQL_URL = \u0026#34;disableMariaDbDriver\u0026#34;; 即，不符合这个acceptsUrl方法条件的，则不会尝试使用 MariaDB 进行连接。\n最终解决方式是在 JDBC 连接字符串上增加了 ?disableMariaDbDriver。\nLike jdbc:mysql://localhost:3306/test?disableMariaDbDriver\n","date":"2021-06-11T14:20:54+08:00","permalink":"/post/2021-06-11-jdbc%E6%95%B0%E6%8D%AE%E5%BA%93%E8%BF%9E%E6%8E%A5mariadb%E7%89%88%E6%9C%AC%E5%86%B2%E7%AA%81%E9%97%AE%E9%A2%98/","title":"JDBC数据库连接MariaDB版本冲突问题"},{"content":"刚才在测数据的时候发现一件事：「60分及格」这个约定似乎与正态分布的规律不谋而合了。\n把一组数做正态分布曲线，如果把正好落在平均数那个点的数的 score 计为 100，那么正好落在平均数+-平均偏离值的那个点的数的 score 则正好是 60 左右。\n神奇！\nfinal GaussianDistributionUtil test = new GaussianDistributionUtil(100d, 30d); for (double i = 100d; i \u0026lt; 10000; i+=10) { final double score = test.calculateScore(i)*100; System.out.println(i + \u0026#34;\\t\u0026#34; + score); if (score == 0) { break; } }    值 分数     100.0 100.0   110.0 94.59594689067654   120.0 80.0737402916808   130.0 60.653065971263345   140.0 41.11122905071875   150.0 24.935220877729623   160.0 13.53352832366127   170.0 6.572852861653048    平均偏离值设置为20时：\n   值 分数     100.0 100.0   110.0 88.24969025845955   120.0 60.653065971263345   130.0 32.465246735834974   140.0 13.53352832366127   150.0 4.393693362340742    ","date":"2021-06-11T14:20:54+08:00","permalink":"/post/2021-08-23-%E5%8F%91%E7%8E%B0%E5%8D%8E%E7%82%B9/","title":"发现华点"},{"content":"昨天浏览项目代码的时候，发现代码中有如下判断：\nList\u0026lt;User\u0026gt; users = userDao.selectUsers(age); for(User user : users) { if (user != null) { // 这里的null判断是我疑惑的点  mqQueue.push(user); } } 感觉如果返回对象属性都是 null 的情况下，Mybatis 应该会返回一个空的 User 对象才对，猜测应该不用进行 null 判断，故做了如下代码修改进行验证：\n  数据库数据准备\nUser表：\n   id age remark1 remark2     1 11     2 11     3 11        User 类\n@Data public class User { private Integer id; private Integer age; private String remark1; private String remark2; }   XML 查询语句\n\u0026lt;select id=\u0026#34;selectUsers\u0026#34; parameterType=\u0026#34;User\u0026#34;\u0026gt; select remark1,remark2 from User where age=\u0026#39;11\u0026#39;     Dao 定义\nList\u0026lt;User\u0026gt; selectUsers();   测试代码\n@Test public void testMybatisNull() { List\u0026lt;User\u0026gt; users = userDao.selectUsers(); System.out.println(users); }   测试结果打印\n[null, null, null]   故当 Mybatis 查询结果不包含必不为空的字段时，应做 null 判断。\n个人认为这是 Mybatis 的问题。可自行使用其他方式（比如查询结果中带上 id 等）避免查询返回对象为 null 的情况。\n","date":"2020-07-08T09:06:54+08:00","permalink":"/post/2020-07-08-mybatis%E6%9F%A5%E8%AF%A2%E8%BF%94%E5%9B%9E%E5%AF%B9%E8%B1%A1%E4%B8%BAnull%E9%AA%8C%E8%AF%81/","title":"mybatis查询返回对象为null验证"},{"content":"读取springboot的配置文件时使用Converter 因为项目中引入了公司自己编写的一个支持 BaseMapper 的 Mybatis 包，但这个自编 Mybatis 包有个问题，没有默认方言配置，不配置方言会报 NPE。\n而 Mybatis 的默认 yaml 文件配置中，没有关于方言的配置，之前项目中使用了丑陋麻烦的注入方案：\n@Configuration @EnableTransactionManagement @AutoConfigureAfter({SpringBootConfiguration.class}) public class MybatisConfig implements TransactionManagementConfigurer { private String dialect = \u0026#34;org.apache.ibatis.dialect.MysqlDialect\u0026#34;; @Autowired private DataSource dataSource; @Bean(name = \u0026#34;sqlSessionFactory\u0026#34;) public SqlSessionFactory sqlSessionFactoryBean() { SqlSessionFactory sqlSessionFactoryBean = new SqlSessionFactoryBean(); sqlSessionFactoryBean.setDataSource(dataSource); sqlSessionFactoryBean.setTypeAliasesPackage(\u0026#34;com.xxxx.xxx\u0026#34;); sqlSessionFactoryBean.setDialect(dialect); ResourcePatternResolver resolver = new PathMatchingResourcePatternResolver(); try { sqlSessionFactoryBean.setMapperLocations(resolver.getResources(\u0026#34;classpath*:com/xxx/xxx/*.xml\u0026#34;)); sqlSessionFactoryBean.getObject().getConfiguration().setMapUnderscoreToCamelCase(true); sqlSessionFactoryBean.getObject().getConfiguration().setMapUnderscoreToCamelCaseForMap(true); return sqlSessionFacotryBean.getObject(); } catch (Exception e) { throw new RuntimeException(e); } } @Bean @Override public PlatformTransactionManager annotationDrivenTransactionManager() { return new DataSourceTransactionManager(dataSource); } @Configuration @AutoConfigureAfter(MybatisConfig.class) public static class MyBatisMapperScannerConfig { @Bean public MapperScannerConfigurer mapperScannerConfigurer() { MapperScannerConfigurer mapperScannerConfigurer = new MapperScannerConfigurer(); mapperScannerConfigurer.setCamelhumpToUnderline(true); mapperScannerConfigurer.setBasePackage(\u0026#34;com.xxx.xxx.**.dao\u0026#34;); mapperScannerConfigurer.setSqlSessionFactoryBeanName(\u0026#34;sqlSessionFactory\u0026#34;); return mapperScannerConfigurer; } } } 如果已经有 Mybatis 的配置类，加入一行方言配置倒是比较方便的做法。\n但我想试试有没有别的办法。\n对代码进行分析，发现在自写的 Configuration 类中，有属性定义protected Dialect dialect;\n问题来了，Configuration 类中的属性，又是什么时候设置的？只要我干涉这个设置方法，就有可能可使配置生效。\n查看 MybatisProperties 类，重点代码缩略如下：\n@ConfigurationProperties(prefix = MybatisProperties.MYBATIS_PREFIX) public class MybatisProperties { public static final String MYBATIS_PREFIX = \u0026#34;mybatis\u0026#34;; /** * A Configuration object for customize default settings. If {@link #configLocation} is specified, this property is * not used. */ @NestedConfigurationProperty private Configuration configuration; } 也就是说，配置文件中以mybatis.configuration为开头的配置都读取了进来，理论上，我配置上以mybatis.configuration.dialect为键的配置，该配置应该就能生效。\n故我做了如下配置：\n  yaml 文件配置：\nmybatis.configuration.dialect:org.apache.ibatis.dialect.MysqlDialect  这样配置以后，启动的时候报异常：无法把一个配置 String 转为一个 Dialect 对象。\n配置中的所有键值，实质上是通过转换器转换为代码中定义的对象类型的，而一些基本的转换器都已经被定义好了，如 String 转 Integer，String 转 Enum 等等，我们现在要做的，就是自己写一个转换器，把org.apache.ibatis.dialect.MysqlDialect转成一个 Dialect 对象，并把这个转换器，注册到框架的转换器的集合中去。\n中间寻找方案的过程就不赘述了，最后转换器的定义：\n 增加将类型转换 Converter\n@Component @ConfigurationPropertiesBinding public class DialectConverter implements Converter\u0026lt;String, Dialect\u0026gt; { @SneakyThrows @Override public Dialect convert(String clazz) { return (Dialect) Class.forName(clazz).getDeclaredConstructor().newInstance(); } }   如上配置后，就可以将方言做正确的配置啦！\n使用 Mybatis 时，自动将枚举和字符串之间进行转换 在定义实体类时，将其中一个岗位定义为了枚举。\n在使用中发现，虽然查询条件中的枚举正常转为了字符串，但查询出来的结果在转为实体类时，该枚举字段值为 null。\n实体类定义：\n@Entity @Table(name = \u0026#34;applicant\u0026#34;) public class Applicant { @Id private String applicantId; private String applicantName; private PositionEnum applicantPosition; //... } 枚举定义：\n/** * 职位枚举 */ public enum PositionEnum { JAVA, H5, ANDROID, IOS; } Dao方法定义：\nList\u0026lt;Applicant\u0026gt; selectByPositionAndIsWorking(@Param(\u0026#34;position\u0026#34;)PositionEnum applicantPosition, @Param(\u0026#34;isWorking\u0026#34;)Integer isWorking); Mapper定义：\n\u0026lt;select id=\u0026#34;selectByPositionAndIsWorking\u0026#34; resultType=\u0026#34;Applicant\u0026#34;\u0026gt; select * from applicant \u0026lt;where\u0026gt; \u0026lt;if test=\u0026#34;isWorking!=null\u0026#34;\u0026gt; is_working = #{isWorking} \u0026lt;/if\u0026gt; \u0026lt;if test=\u0026#34;position!=null\u0026#34;\u0026gt; and applicant_position = #{position} \u0026lt;/if\u0026gt; \u0026lt;/where\u0026gt; \u0026lt;/select\u0026gt; 如上，\n运行时翻译得到的 SQL 语句是正常的：\nselectapplicant_id,applicant_name,applicant_position,is_workingfromapplicantwhereis_working=1andapplicant_position=\u0026#39;JAVA\u0026#39;;但是查出来的结果，Applicant 对象中的 applicantPosition 结果却为 null。\n分析认为需要配置一个转换器。\n修改 yaml 文件：\nmybatis.configuration.default-enum-type-handler:org.apache.ibatis.type.EnumTypeHandler","date":"2020-04-08T16:01:54+08:00","permalink":"/post/2020-04-08-%E5%A6%82%E4%BD%95%E5%9C%A8ssm%E9%A1%B9%E7%9B%AE%E4%B8%AD%E4%BC%98%E9%9B%85%E5%9C%B0%E4%BD%BF%E7%94%A8converter/","title":"如何在ssm项目中优雅地使用Converter"},{"content":"[231]2的幂 我一开始解题的时候，思路是：为2的幂的数字有一个共同点——2进制的时候最高位为1，后面都为0。所以该数-1，二进制数的所有数都为1。\n初版代码：\nclass Solution { public boolean isPowerOfTwo(int n) { if (n == 1) { return true; } if (n \u0026lt;= 0) { return false; } String s = Integer.toBinaryString(n - 1); return !s.contains(\u0026#34;0\u0026#34;); } } 解题结果：\n 23:01\tinfo ​\t解答成功: ​\t执行耗时:2 ms,击败了26.88% 的Java用户 ​\t内存消耗:39.1 MB,击败了5.23% 的Java用户\n 不管是耗时还是内存都比较差。\n故寻求答案发现，其实我在上面解答的时候就已经意识到了这个问题，追深一层：\n   32 1 0 0 0 0     31 0 1 1 1 1   \u0026amp; 0 0 0 0 0    可推导2的幂的另一个共同点：x \u0026amp; (x-1) = 0\n故代码修改为：\nclass Solution { public boolean isPowerOfTwo(int n) { if (n == 1) { return true; } if (n \u0026lt;= 0) { return false; } return (n \u0026amp; (n - 1)) == 0; } } ","date":"2020-02-10T23:19:54+08:00","permalink":"/post/2020-02-10-leetcode%E5%88%B7%E9%A2%98%E7%AC%94%E8%AE%B0/","title":"leetcode刷题笔记"},{"content":"入门 Service 是分布式集群架构的核心，特征：\n 拥有一个唯一指定的名字 拥有一个虚拟 IP 和端口号 能够提供某种远程服务能力 被映射到了提供这种服务能力的一组容器应用上  容器提供了强大的隔离功能，所以有必要把为 Service 提供服务的这组进程放入容器中隔离。为此，Kubernetes 设计了 Pod 对象，将每个服务进程包装到相应的 Pod 中，使其成为 Pod 中运行的一个 Container。\n为 Pod 贴上标签，为 Service 定义标签选择器 Label Selector，以此关联 Pod 和 Service。\ngraph TD A[Node 虚拟机/物理机] --\u0026gt; B(Pod) A --\u0026gt; C(Pod) A --\u0026gt; D(Pod) C --\u0026gt; E((Pause)) C --\u0026gt; F(业务容器) C --\u0026gt; G(业务容器) C --\u0026gt; H(业务容器) E --\u0026gt;|共享| F E --\u0026gt;|共享| G E --\u0026gt;|共享| H ","date":"2019-04-09T10:54:54+08:00","permalink":"/post/2019-04-09-kubernetes%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/","title":"kubernetes学习笔记"},{"content":" 图片  Lorem est tota propiore conpellat pectoribus de pectora summo.\nRedit teque digerit hominumque toris verebor lumina non cervice subde tollit usus habet Arctonque, furores quas nec ferunt. Quoque montibus nunc caluere tempus inhospita parcite confusaque translucet patri vestro qui optatis lumine cognoscere flos nubis! Fronde ipsamque patulos Dryopen deorum.\n Exierant elisi ambit vivere dedere Duce pollice Eris modo Spargitque ferrea quos palude  Rursus nulli murmur; hastile inridet ut ab gravi sententia! Nomine potitus silentia flumen, sustinet placuit petis in dilapsa erat sunt. Atria tractus malis.\n Comas hunc haec pietate fetum procerum dixit Post torum vates letum Tiresia Flumen querellas Arcanaque montibus omnes Quidem et  Vagus elidunt The Van de Graaf Canon\nMane refeci capiebant unda mulcebat Victa caducifer, malo vulnere contra dicere aurato, ludit regale, voca! Retorsit colit est profanae esse virescere furit nec; iaculi matertera et visa est, viribus. Divesque creatis, tecta novat collumque vulnus est, parvas. Faces illo pepulere tempus adest. Tendit flamma, ab opes virum sustinet, sidus sequendo urbis.\nIubar proles corpore raptos vero auctor imperium; sed et huic: manus caeli Lelegas tu lux. Verbis obstitit intus oblectamina fixis linguisque ausus sperare Echionides cornuaque tenent clausit possit. Omnia putatur. Praeteritae refert ausus; ferebant e primus lora nutat, vici quae mea ipse. Et iter nil spectatae vulnus haerentia iuste et exercebat, sui et.\nEurytus Hector, materna ipsumque ut Politen, nec, nate, ignari, vernum cohaesit sequitur. Vel mitis temploque vocatus, inque alis, oculos nomen non silvis corpore coniunx ne displicet illa. Crescunt non unus, vidit visa quantum inmiti flumina mortis facto sic: undique a alios vincula sunt iactata abdita! Suspenderat ego fuit tendit: luna, ante urbem Propoetides parte.\n","date":"2019-03-09T00:00:00Z","image":"/post/placeholder-text/matt-le-SJSpo9hQf7s-unsplash_hu958d513eeefe5556a31d065479ecc5ac_14205_120x120_fill_q75_box_smart1.jpg","permalink":"/post/placeholder-text/","title":"Placeholder Text"},{"content":"背景 今年公司在申请 ISO-9000，因此多了很多质量上的管理要求。之前听到测试部提出需要做大覆盖量的集成测试，感到非常不妥。因为目前我们使用的技术是微服务技术，且有相当一部分数据依赖于外部系统（如银联接口等），如果做集成测试，由于服务很多，因此第一，很难保证数据的一致性；第二，很难保证其他服务的稳定程度。后果就是出现错误的概率高、维护成本高、排查问题的成本高。\n因此我在网上搜索微服务适用的测试框架，发现现在有些新的测试框架是基于契约的测试，这样对微服务来说会更友好。\n由于目前项目使用的就是 spring cloud，因此选择了目前已经较成熟的契约测试框架 spring cloud contract 进行实践调研。\nspring cloud contract 官方文档地址\n代码实践 本地场景 由于一个项目组几乎都维护着多个服务，某个开发任务可能需要同时修改多个系统。因此在开发自测时，需要用本地的契约测试。\n服务端  导入 gradle 配置：  buildscript { ext { //...  springCloudContractVersion = \u0026#39;2.0.1.RELEASE\u0026#39; } dependencies { //...  classpath(\u0026#39;org.springframework.cloud:spring-cloud-contract-gradle-plugin:${springCloudContractVersion}\u0026#39;) } } //... apply plugin: \u0026#39;spring-cloud-contract\u0026#39; apply plugin: \u0026#39;maven-publish\u0026#39; dependencyManagement { imports { //...  mavenBom \u0026#39;org.springframework.cloud:spring-cloud-contract-dependencies:\u0026#39; + springCloudContractVersion } } dependencies { //...  testCompile(\u0026#39;org.springframeword.cloud:spring-cloud-starter-contract-verifier\u0026#39;) } contracts { // 基类所在的包  packageWithBaseClasses \u0026#39;com.carolinetest.appmanage.contract\u0026#39; } // contract publish publishing { publications { stubs(MavenPublication) { groupId \u0026#39;com.carolinetest\u0026#39; artifactId \u0026#39;appmanage-stubs\u0026#39; version \u0026#39;0.0.1\u0026#39; artifact verifierStubsJar } } repositories { mavenLocal() } } 待测试接口为：\n@GetMapping(\u0026#34;/app/appmanage/msgtemplate/findAlertOvertimeTemplateId\u0026#34;) public Map\u0026lt;String, Object\u0026gt; findAlertOvertimeTemplateId(@RequestParam String channelNo) { return success(msgTemplateService.findAlertOvertimeTemplateId(channelNo)); }  编写 contract 基类，放在 build.gradle 中配置的 packageWithBaseClasses 目录下：  @RunWith(SpringJUnit4ClassRunner.class) @SpringBootTest(classes = {Application.class}) public class ContractVerifierBase { @MockBean protected MsgTemplateService msgTemplateService; @Autowired protected MsgTemplateForAppController msgTemplateForAppController; // 接口所在的类  @Autowired // 不能省略  protected WebApplicationContext webApplicationContext; @Before // 这个注解千万别漏了！！！  public void setup() throws Exception { RestAssuredMockMvc.standaloneSetup(msgTemplateForAppController); MsgTemplate msg1 = new MsgTemplate(); MsgTemplate msg2 = new MsgTemplate(); MsgTemplate msg3 = new MsgTemplate(); // complete object  List\u0026lt;MsgTemplate\u0026gt; msgList = new ArrayList\u0026lt;\u0026gt;(); msgList.add(msg1); msgList.add(msg2); msgList.add(msg3); } }  编写 groovy 脚本，放在 src.test.resources.contracts 目录下：  Contract.make { description(\u0026#34;find_alert_overtime_template\u0026#34;) //描述  request { // 请求契约，可使用正则  url \u0026#39;/app/appmanage/msgtemplate/findAlertOvertimeTemplateId\u0026#39; method \u0026#39;GET\u0026#39; } response { // 返回契约  status 200 headers { contentType(applicationJsonUtf8) } body(\u0026#39;\u0026#39;\u0026#39; { \u0026#34;head\u0026#34; : { \u0026#34;retFlag\u0026#34;:\u0026#34;00000\u0026#34;, \u0026#34;retMsg\u0026#34;:\u0026#34;处理成功\u0026#34; }, \u0026#34;body\u0026#34; : [ { \u0026#34;templateId\u0026#34;:\u0026#34;0587147ea649403db9bfba52aac3decb\u0026#34;, \u0026#34;alertOvertime\u0026#34;:10 }, { \u0026#34;templateId\u0026#34;:\u0026#34;6282bce9384c48dc9148fc718d45aa87\u0026#34;, \u0026#34;alertOvertime\u0026#34;:10 } ] } \u0026#39;\u0026#39;\u0026#39;) } }   执行 gradle generateContractTests，生成测试位于 build/generated-test-sources/contracts 下。\n生成的测试如下图：  contractverifiertest \n  直接运行该测试，即可进行单元测试。\n  执行 gradle publishStubsPublicationToLocalRepository 发布到本地仓库。\n  查看本地仓库，已生成契约 stub。\n 本地仓库 \n  消费端   导入 gradle 配置，基本与服务端相同\n  正常编写单元测试：\n@RunWith(SpringRunner.class) @SpringBootTest @AutoConfigureStubRunner(ids = {\u0026#34;com.carolinetest:appmanage-stubs:0.0.1:8095\u0026#34;}, workOffline = true) @WebAppConfiguration public class AppManageServiceContractTest { private static final Log logger = LogFactory.getLog(AppManageServiceContractTest.class); @Autowired private StubFinder stubFinder; @Test public void findAlertOvertimeMsgTest() { int port = stubFinder.findStubUrl(\u0026#34;com.carolinetest\u0026#34;, \u0026#34;appmanage-stubs\u0026#34;).getPort(); Map\u0026lt;String, Object\u0026gt; result = HttpUtil.restExchangeMapOrigin(HttpMethod.GET, \u0026#34;http://localhost:\u0026#34; + port + \u0026#34;/app/appmanage/msgtemplate/findAlertOvertimeTemplateId\u0026#34;, null); logger.info(\u0026#34;result:\u0026#34; + result); Assert.assertTrue(HttpUtil.isSuccess(result)); } } 其中 @AutoConfigureStubRunner的 ids 配置坑很多，需要特别注意。当 workOffline 是 true 时，配置格式为：\n{groupId}:{artifactId}:{version}:{port}\n其中 version 可写成「+」加号，意为自动使用最高版本；\nport 意为 stub 包启动端口号，可省略，不配置的时候使用默认端口号启动。\n  运行该单元测试，执行成功！\n  共连 maven 私服场景 服务端   增加 maven 库配置 gradle.properties:\n# Project-wide Gradle settings. RELEASE_REPOSITORY_URL=http://10.164.194.139:8081/nexus/content/repostiries/release/ SNAPSHOT_REPOSITORY_URL=http://10.164.194.139:8081/nexus/content/repositories/snapshots/ # nexus服务器 NEXUS_USERNAME=admin NEXUS_PASSWORD=admin123   修改 build.gradle:\n//... publishing { //...  repositories { mavenLocal() maven { url RELEASE_REPOSITORY_URL credentials { username = NEXUS_USERNAME password = NEXUS_PASSWORD } } } }   发布\n只发布到远端 maven 库：\ngradle publishStubsPublicationToMavenRepository\n发到所有配置的发布渠道（本地库和远端 maven 库）：\ngradle publish\n  查看，均已发布成功！\n stubspublish \n  消费端   修改@AutoConfigureStubRunner\nids = {\u0026ldquo;com.carolinetest:appmanage-stubs:+\u0026rdquo;, repositoryRoot = \u0026ldquo;http://10.164.194.139:8081/nexus/content/repostiries/release/\u0026quot;}\n  运行单元测试，成功！\n  在测试中，出现一个错误，程序报错：\nCaused by: java.lang.IllegalStateException: The artifact was found in the local repository but you have explicitly stated that it should be downloaded from a remote one 报错原因：\n本地 maven 库包与远端 maven 库包有一样的版本号，但本地 maven 库包更新（发布时间更晚），因此报错。\n解决方法：\n 删除本地 maven 库的包； 在服务端重新执行 publish 至远端；  注意：如果要同时发布至本地和远端 maven 库，直接使用 publish 命令即可，最好不要分别发布！如果必须分别发布，请先发布本地，再发布远端！\n","date":"2018-11-21T16:33:54+08:00","permalink":"/post/2018-11-21-spring-cloud-contract%E5%A5%91%E7%BA%A6%E6%B5%8B%E8%AF%95%E5%AE%9E%E8%B7%B5/","title":"Spring Cloud Contract契约测试实践"},{"content":"Docker概览 Docker 容器的概念约等于虚拟机。\nDocker 底层   Namespaces 命名空间\n为 Docker 容器提供操作系统层面的隔离\n  Control Groups 控制组\n为 Docker 容器提供硬件层面的隔离\n  Union File System 联合文件系统\n利用分层 layer 思想管理镜像和容器\n  镜像 镜像是一个 Docker 的可执行文件，通过镜像可以创建一个或多个容器。\n docker镜像常用操作 \n镜像搜索   命令格式： ​\tdocker search [OPTIONS] TERM\n  命令参数(OPTIONS)：\n   -f, --filter filter 根据提供的格式筛选结果 --format string 利用Go语言的format格式化输出结果 --limit int 展示最大的结果数，默认25个 --no-trunc 内容全部显示 本地镜像 docker pull 作用： ​\t下载远程仓库（如Docker Hub）中的镜像 命令格式： ​\tdocker pull [OPTIONS] NAME[:TAG|@DIGEST] 命令参数(OPTIONS)： ​\t-a, \u0026ndash;all-tags 下载所有符合给定tag的镜像\ndocker images 作用： ​\t列出本地镜像 命令格式： ​\tdocker images [OPTIONS][REPOSITORY[:TAG]]\n​ 或者 docker image ls [OPTIONS][REPOSITORY[:TAG]]\n命令参数(OPTIONS)： ​\t-a, \u0026ndash;all 展示所有镜像 (默认隐藏底层的镜像) ​\t\u0026ndash;no-trunc 不缩略显示 ​\t-q, \u0026ndash;quiet 只显示镜像ID\ndocker rmi/docker image rm 作用： ​\t将本地的一个或多个镜像删除 命令格式： ​\tdocker rmi [OPTIONS] IMAGE [IMAGE...]\n​ 或者 docker image rm [OPTIONS] IMAGE [IMAGE...]\n命令参数(OPTIONS)：\t​\t-f, \u0026ndash;force 强制删除\ndocker save 作用：\n​\t将本地的一个或多个镜像打包保存成本地tar文件(输出到STDOUT)\n命令格式：\n​\tdocker save [OPTIONS] IMAGE [IMAGE...]\n命令参数(OPTIONS)：\n​\t-o, \u0026ndash;output string 指定写入的文件名和路径\ndocker save centos:7 \u0026gt; centosfile.tar\ndocker save centos:7 -o centosfile.tar\nsave 的时候最好用指定名称+版本号的方式，不然 load 进来后名称和版本号就是 null。\ndocker load 作用：\n​\t将save命令打包的镜像导入本地镜像库中\n命令格式：\n​\tdocker load [OPTIONS] 命令参数(OPTIONS)：\n​\t-i, \u0026ndash;input string 指定要打入的文件，如没有指定，默认是STDIN\n​\t-q, \u0026ndash;quiet 不打印导入过程信息\ndocker tag 作用：\n​\t对本地镜像的NAME、TAG进行重命名，并新产生一个命名后镜像\n命令格式：\n​\tdocker tag SOURCE_IMAGE[:TAG] TARGET_IMAGE[:TAG]\n当对一个正常镜像重命名时，会新建一个引用；当对一个无名称和 tag 的镜像重命名时，会修改原镜像名称。\ndocker image inspect 作用：\n​\t查看本地一个或多个镜像的详细信息\n命令格式：\n​\tdocker image inspect [OPTIONS] IMAGE [IMAGE...]\n命令参数(OPTIONS)：\t​\t-f, \u0026ndash;format string 利用特定Go语言的format格式输出结果\nE:\\code\\dockerfiles\u0026gt;docker image inspect -f \u0026#34;{{json .Metadata.LastTagTime}}\u0026#34; ubuntu \u0026#34;0001-01-01T00:00:00Z\u0026#34; E:\\code\\dockerfiles\u0026gt;docker image inspect -f \u0026#34;{{json .Metadata}}\u0026#34; ubuntu {\u0026#34;LastTagTime\u0026#34;:\u0026#34;0001-01-01T00:00:00Z\u0026#34;} docker history 作用：\n​\t查看本地一个镜像的历史(历史分层)信息\n命令格式：\n​\tdocker history [OPTIONS] IMAGE\n命令参数(OPTIONS)：\n​\t-H, \u0026ndash;human\t将创建时间、大小进行优化打印(默认为true)\n​\t-q, \u0026ndash;quiet 只显示镜像ID\n​\t\u0026ndash;no-trunc 不缩略显示\n容器 容器是一种轻量级、可移植、并将应用程序进行打包的技术，使应用程序可以在几乎任何地方以相同的方式运行。\nDocker 将镜像文件运行起来后，产生的对象就是容器。容器相当于是镜像运行起来的一个实例。容器具备一定的生命周期。\n可以借助 docker ps 命令查看运行的容器。\n容器与虚拟机 相同点  硬件资源共享使用 生命周期相似 可以安装应用 数据会存储在宿主机上(/var/lib/docker/containers)  不同点  虚拟机是一个完整的操作系统，容器运行在宿主机的内核上（本质上一系列进程的结合） 容器轻量级，虚拟机重量级  容器的生命周期  docker容器生命周期 \n创建容器 docker create 作用： ​\t利用镜像创建出一个Created 状态的待启动容器 命令格式： ​\tdocker create [OPTIONS] IMAGE [COMMAND][ARG...] 命令参数(OPTIONS)：查看更多 ​\t-t, \u0026ndash;tty 分配一个伪TTY，也就是分配虚拟终端 ​ -i, \u0026ndash;interactive 即使没有连接，也要保持STDIN打开 ​ \u0026ndash;name 为容器起名，如果没有指定将会随机产生一个名称 命令参数（COMMAND\\ARG）: ​\tCOMMAND 表示容器启动后，需要在容器中执行的命令，如ps、ls 等命令 ​\tARG 表示执行 COMMAND 时需要提供的一些参数，如ps 命令的 aux、ls命令的-a等等\n删除容器 docker rm docker rm [OPTIONS] CONTAINER [CONTAINER...]\n可以指定为容器的名字或 id。\n启动容器 docker start 作用： ​\t将一个或多个处于创建状态或关闭状态的容器启动起来 命令格式： ​\tdocker start [OPTIONS] CONTAINER [CONTAINER...] 命令参数(OPTIONS)： ​\t-a, \u0026ndash;attach\t将当前shell的 STDOUT/STDERR 连接到容器上 ​\t-i, \u0026ndash;interactive\t将当前shell的 STDIN连接到容器上\n只有创建的时候有 -i 参数，这里的 -i 才有效。\n创建容器并启动 docker run 作用： ​\t利用镜像创建并启动一个容器 命令格式： ​\tdocker run [OPTIONS] IMAGE [COMMAND][ARG...] 命令参数(OPTIONS)：查看更多 ​\t-t, \u0026ndash;tty 分配一个伪TTY，也就是分配虚拟终端 ​ -i, \u0026ndash;interactive 即使没有连接，也要保持STDIN打开 ​ \u0026ndash;name 为容器起名，如果没有指定将会随机产生一个名称 ​\t-d, \u0026ndash;detach\t在后台运行容器并打印出容器ID ​\t\u0026ndash;rm\t当容器退出运行后，自动删除容器 命令参数（COMMAND\\ARG）: ​\tCOMMAND 表示容器启动后，需要在容器中执行的命令，如ps、ls 等命令 ​\tARG 表示执行 COMMAND 时需要提供的一些参数，如ps 命令的 aux、ls命令的-a等等\n docker run 相当于 docker create + docker start –a 前台模式 docker run -d 相当于 docker create + docker start 后台模式  容器关闭 docker stop 作用： ​\t关闭一个或多个处于暂停状态或者运行状态的容器 命令格式： ​\tdocker stop [OPTIONS] CONTAINER [CONTAINER...] 命令参数(OPTIONS)： ​\t-t, \u0026ndash;time int 关闭前，等待的时间，单位秒(默认 10s)\nstop 命令使用 kill -term 杀掉进程\n容器终止 doker kill 作用： ​\t强制并立即关闭一个或多个处于暂停状态或者运行状态的容器 命令格式： ​\tdocker kill [OPTIONS] CONTAINER [CONTAINER...] 命令参数(OPTIONS)： ​\t-s, \u0026ndash;signal string 指定发送给容器的关闭信号 (默认“KILL”信号)\n比如 kill -9 可以写为 docker kill 容器名 -s \u0026lsquo;9\u0026rsquo;\n容器暂停/取消暂停 docker pause/unpause 作用： ​\t暂停一个或多个处于运行状态的容器 命令格式： ​\tdocker pause CONTAINER [CONTAINER...]\n作用： ​\t取消一个或多个处于暂停状态的容器，恢复运行 命令格式： ​\tdocker unpause CONTAINER [CONTAINER...]\n容器重启 docker restart 作用： ​\t重启一个或多个处于运行状态、暂停状态、关闭状态或者新建状态的容器 命令格式： ​\tdocker restart [OPTIONS] CONTAINER [CONTAINER\u0026hellip;] 命令参数(OPTIONS)： ​\t-t, \u0026ndash;time int 重启前，等待的时间，单位秒(默认 10s) ​\t实则是关闭前等待的时间\n该命令相当于stop和start命令的结合\n容器信息 容器详细信息 docker container inspect 作用： ​\t查看本地一个或多个容器的详细信息 命令格式： ​\tdocker container inspect [OPTIONS] CONTAINER [CONTAINER...] ​ 或者 docker inspect [OPTIONS] CONTAINER [CONTAINER...] 命令参数(OPTIONS)： ​\t-f, \u0026ndash;format string\t利用特定Go语言的format格式输出结果 ​\t-s, \u0026ndash;size\t显示总大小\n容器日志 docker logs 作用： ​\t查看容器的日志信息 命令格式： ​\tdocker logs [OPTIONS] CONTAINER 命令参数(OPTIONS)： ​\t\u0026ndash;details\t显示日志的额外信息 ​\t-f, \u0026ndash;follow 动态跟踪显示日志信息 ​\t\u0026ndash;since string 只显示某事时间节点之后的 \u0026ndash;tail string 显示倒数的行数(默认全部) ​\t-t, \u0026ndash;timestamps 显示timestamps时间 ​\t\u0026ndash;until string 只显示某时间节点之前的 注意： ​\t容器日志中记录的是容器主进程的输出STDOUT\\STDERR，也就是说 attach 命令输出的会在 logs 中输出，而 exec 的则不会。\n容器重命名 docker rename 作用： ​\t修改容器的名称 命令格式： ​\tdocker rename CONTAINER NEW_NAME\n容器运行时操作 容器连接 docker attach 作用： ​\t将当前终端的STDIN、STDOUT、STDERR绑定到正在运行的容器的主进程上实现连接 命令格式： ​\tdocker attach [OPTIONS] CONTAINER 命令参数(OPTIONS)： ​\t\u0026ndash;no-stdin 不绑定STDIN\n这个命令实际上是把当前的控制台绑定到 docker 容器的主进程（即 commond 执行的那个进程）上的，如果 commond 那个命令的进程退出了，那么这个 docker 容器运行也就终止了。\n容器中执行新命令 docker exec 作用： ​\t在容器中运行一个命令 命令格式： ​\tdocker exec [OPTIONS] CONTAINER COMMAND [ARG\u0026hellip;] 命令参数(OPTIONS)： ​\t-d, \u0026ndash;detach 后台运行命令 ​\t-i, \u0026ndash;interactive\t即使没连接容器，也将当前的STDIN绑定上 ​\t-t, \u0026ndash;tty 分配一个虚拟终端 ​\t-w, \u0026ndash;workdir string 指定在容器中的工作目录 ​\t-e, \u0026ndash;env list 设置容器中运行时的环境变量\n容器与镜像  1547970788929 \n容器提交 docker commit 作用： ​\t根据容器生成一个新的镜像 命令格式： ​\tdocker commit [OPTIONS] CONTAINER [REPOSITORY[:TAG]] 命令参数(OPTIONS)： ​\t-a, \u0026ndash;author string 作者 ​\t-c, \u0026ndash;change list 为创建的镜像加入Dockerfile命令 ​\t-m, \u0026ndash;message string 提交信息，类似git commit -m ​\t-p, \u0026ndash;pause 提交时暂停容器 (default true)\n","date":"2018-10-28T16:17:54+08:00","permalink":"/post/2018-10-28-docker%E6%A0%B8%E5%BF%83%E6%8A%80%E6%9C%AF%E5%8E%9F%E7%90%86%E5%8F%8A%E5%85%B6%E5%BA%94%E7%94%A8%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/","title":"「Docker核心技术原理及其应用学习笔记」"},{"content":"镜像 获取镜像 docker pull [选项] [Docker Registry 地]\n","date":"2018-08-17T11:25:54+08:00","permalink":"/post/2018-08-17-docker%E5%AD%A6%E4%B9%A0/","title":"Docker学习"},{"content":"基础 数据类型 Python 3 中有 6 种标准的数据类型：Number, String, List, Tuple, Sets, Dictionary。\n其中 Number 类型有 3 种：整型 int，浮点型 float，复数 complex。\n整型 int 整型没有限制大小，可以当作 long 类型使用。\n在整数除法中，/的结果是浮点型，//的结果才是整型，相当于 Java 中的除，在 Python 中叫「地板除」。\n浮点型 float 浮点型参与的任何计算结果都是浮点型，包括除、余、地板除。\n复数 complex 复数由实数部分和虚数部分构成，可以用 a+bj 或 complex(a,b) 表示，复数的实部 a 和虚部 b 都是浮点型。\n数据类型转换   int(x) 将 x 转换为整型\n如果 x 为浮点，则简单粗暴地削去其小数部分\n  float(x) 将 x 转换为浮点型\n  complex(x) 将 x 转换为复数，虚数部分为 0。\n  complex(x, y) 将 x 和 y 转换为复数。\n  常量  PI:圆周率 E:自然对数  变量和关键字 变量 命名变量：\n# 命名无需定义类型 name = \u0026#39;SunXiaoHong\u0026#39; # 可以给同一个变量赋不同类型的值 name = 14 name = 2.14 # 获取变量的类型 type(name) # 输出\u0026lt;class \u0026#39;float\u0026#39;\u0026gt; 当将一个变量赋给另一个变量时，事实上是将它所指的值的地址给了这个变量。\na = \u0026#39;ABC\u0026#39; b = a a = \u0026#39;EFG\u0026#39; print(b) # 输出：ABC 变量名称 变量名称必须以字母开头，建议使用小写字母开头。\nPython 使用下划线式命名。\n不能使用关键字命名。\n False\tNone\tTrue\tand\tas\tassert break\tclass\tcontinue\tdef\tdel elif\telse\texcept\tfinally\tfor\tfrom global\tif\timport\tin\tnonlocal lambda\tis\tnot\tor\tpass\traise return\ttry\twhile\twith\tyield\n 运算符和操作对象 运算符 Python 支持以下 7 种运算符：\n 算术运算符 比较运算符 赋值运算符 逻辑运算符 位运算符 成员运算符 身份运算符  算术运算符    运算符 描述 实例     + 加 a+b=15   - 减 a-b=5   * 乘 a*b=50   / 除 a/b=2.0   % 模 a%b=0   ** 幂 a**b=100000   // 地板除 9//2=4 9.0//2.0=4.0    比较运算符    运算符 描述 实例     == 等于 a==b 返回 False   != 不等于 a!=b 返回 True   \u0026gt; 大于    \u0026lt; 小于    \u0026gt;= 大于等于    \u0026lt;= 小于等于     赋值运算符    运算符 实例     =    += c = c + a   -= c = c - a   *= c = c * a   /= c = c / a   %= c = c % a   **= c = c ** a   //= c = c // a    位运算符   \u0026amp; 按位与：\n1001 \u0026amp; 1100 得 1000\n  | 按位或：\n1001 | 1100 得 1101\n  ^ 按位异或（相异取 1）：\n1001 ^ 1100 得 0101\n  ~ 按位取反：\n~1001 得 0110\n  \u0026laquo; 左移（高位丢弃，低位补 0）：\n1001 \u0026laquo; 2 得 0100\n  \u0026gt;\u0026gt; 右移（低位丢弃，高位补0）：\n1001 \u0026raquo; 2 得 0010\n  逻辑运算符 在python中，任何对象都可以用bool(对象)的方式来进行判断，只有以下情况结果为false: 0，None，空字符串，空集合，false布尔值。\n   运算符 逻辑表达式 描述 实例（a = 10, b = 20）     and x and y x 为 False 则返回 False; 否则返回 y 的值 a and b 得 20   or x or y x 为 True 则返回 x 的值；否则返回 y 的值 a or b 得 10   not not x 即 ! ，只返回 True 和 False not(a and b) 得 False    成员运算符    运算符 描述     in 即 Java 的 List 中的 contains   not in in 取反    身份运算符    运算符 描述     is 是否引用自同一个对象   is not is 取反    a = 10 b = 10 print(a is b) # True 运算符优先级 从高到低：\n**\n~ +(位运算) -（位运算）\n* / % //\n+ -\n\u0026gt;\u0026gt; \u0026lt;\u0026lt;\n\u0026amp;\n^ |\n\u0026lt;= \u0026lt; \u0026gt; \u0026gt;=\n\u0026lt;\u0026gt; == !=\n= %= /= //= -= += *= **=\nis is not\nin not in\nnot or and\n字符串操作 字符串不能进行除法和减法；\n乘法只可以乘以数字；\nprint(\u0026#39;world\u0026#39;*3) # 输出:worldworldworld 列表和元组 通用序列操作 Python 中所有序列都可以进行一些特定操作，包括索引、分片、序列相加、乘法、成员资格、长度、最小值和最大值。\nPython 中的序列包括字符串、元组和列表。\n索引 可以通过中括号的方式来获取相应索引对应的值。\n字符串即是用字符组成的序列。\n使用负值索引可以从右向左获取，最右的索引为-1。\ntest = \u0026#39;abcdefg\u0026#39; print(test[0]) #a print(test[2]) #c print(test[-1]) #g print(test[-5]) #c print(test[7]) #IndexError 分片 使用分片对一定范围内的元素进行访问。\ntest = \u0026#39;abcdefg\u0026#39; print(test[1:3]) #bc print(test[-3:-1]) #ef print(test[-3:3]) #不会报错，得到一个空字符串 print(test[-1:-3]) #空串 print(test[1:]) #bcdefg print(test[-2:]) #fg print(test[:3]) #abc number = [0,1,2,3,4,5,6,7,8,9] print(number[:]) #[0, 1, 2, 3, 4, 5, 6, 7, 8, 9]  包左不包右 左留空则从第一个元素开始输出，右留空则输出至最后一个元素  分片中有一个隐式参数即步长，默认为1\nprint(number[1:8:1]) #[1, 2, 3, 4, 5, 6, 7] print(number[1:8:2]) #[1, 3, 5, 7] print(number[::3]) #[0, 3, 6, 9] print(number[3:1]) #[] print(number[3:1:-1]) #[3, 2]  步长 \u0026gt; 0 时，只能从左边的元素向右边的元素输出； 步长 \u0026lt; 0 时，只能从右边的元素向左边的元素输出； 步长 = 0 则会报错。  序列相加 同类型的序列可以用加号组合成一个序列。\nprint([5,3,7] + [4,5,8]) #[5, 3, 7, 4, 5, 8] print(\u0026#34;aaa\u0026#34; + \u0026#34;bbb\u0026#34;) #aaabbb print([1,2] + \u0026#39;12\u0026#39;) #报错 乘法 复制 N 份原序列的元素，放入一个大的序列中。\nprint(\u0026#39;a\u0026#39; * 5) #aaaaa print([1, 2] * 5) #[1, 2, 1, 2, 1, 2, 1, 2, 1, 2] print([None] * 5) #[None, None, None, None, None] 用于初始化序列 print([1] * 0) #[] 成员资格 相当于 contains。\ngreeting = \u0026#39;hello, world3\u0026#39; print(\u0026#39;w\u0026#39; in greeting) #True print(\u0026#39;,\u0026#39; in greeting) #True print(\u0026#34; \u0026#34; in greeting) #True users = [\u0026#39;Jim\u0026#39;, \u0026#39;Lily\u0026#39;, \u0026#39;John\u0026#39;] print(\u0026#39;Jim\u0026#39; in users) #True print(\u0026#39;J\u0026#39; in users) #False numbers = [1, 5, 7, 10] print(1 in numbers) #True print(\u0026#39;1\u0026#39; in numbers) #False print(3 in users) #False print(3 in greeting) #报错    in 操作 字符串 列表     数字 报错 OK   字符 OK OK    长度、最小值、最大值 print(len(greeting)) #13 print(max(greeting)) #w print(min(greeting)) #（空格） print(len(users)) #3 print(max(users)) # Lily print(min(users)) # Jim numbers = [1, 5, 7, 10, \u0026#39;aa\u0026#39;] print(max(numbers)) #报错 print(min(numbers)) #报错 字符串的大小比较方法：先比较两个对象的第0个元素，大小关系即为对象的大小关系，如果相等则继续比较后续元素，先终止迭代的认为是小的。\n列表 更新列表 元素赋值 numbers[2] = 28\n不可越界赋值。\n增加元素 numbers.append(28)\n添加到列表末尾。\n删除元素 del numbers[2]\n会导致列表长度缩短。该角标后还有元素的话，会向前缩进。\n分片赋值 list()函数可将字符串转为字符列表。\n用前面说到的分片的语法，可将对应的分片进行赋值。但无法使用步长。\nletters = list(\u0026#39;Shitbow is a SB\u0026#39;) letters[-2:] = list(\u0026#39;lovely boy\u0026#39;) print(letters) #[\u0026#39;S\u0026#39;, \u0026#39;h\u0026#39;, \u0026#39;i\u0026#39;, \u0026#39;t\u0026#39;, \u0026#39;b\u0026#39;, \u0026#39;o\u0026#39;, \u0026#39;w\u0026#39;, \u0026#39; \u0026#39;, \u0026#39;i\u0026#39;, \u0026#39;s\u0026#39;, \u0026#39; \u0026#39;, \u0026#39;a\u0026#39;, \u0026#39; \u0026#39;, \u0026#39;l\u0026#39;, \u0026#39;o\u0026#39;, \u0026#39;v\u0026#39;, \u0026#39;e\u0026#39;, \u0026#39;l\u0026#39;, \u0026#39;y\u0026#39;, \u0026#39; \u0026#39;, \u0026#39;b\u0026#39;, \u0026#39;o\u0026#39;, \u0026#39;y\u0026#39;] aaa = list(\u0026#39;abcd\u0026#39;) aaa[-2:] = [] print(aaa) #[\u0026#39;a\u0026#39;, \u0026#39;b\u0026#39;] 相当于分片删除 嵌套列表 列表中的元素本身也可以是个列表。\n列表方法   append\nlist.append(元素)\n追加\n  count\nlist.count(元素)\n统计某元素出现次数\n  extend\na_list.extend(b_list)\n扩展列表。\n与 + 的区别：改变了 a_list 本身\n  index\nlist.index(元素)\n获取列表中的第一个匹配该元素的索引。若该元素不存在，则会报错。\n  insert\nlist.insert(索引, 元素)\n在列表中对应的索引位置插入元素\n  pop\nlist.pop([索引])\n移除列表中对应索引（默认为最后一个）的元素，并返回改元素\n  remove\nlist.remove(元素)\n移除列表中某个值的第一个匹配项。没有返回值。若该元素不存在，则报错。\n  reverse\nlist.reverse()\n反转，改变原列表\n  reversed\nreversed(list)\n反转，不改变原列表，返回一个新的迭代器对象。\nlist1 = [1,2,3] list2 = reversed(list1) print(list1) #[1, 2, 3] print(list(list2)) #[3, 2, 1]   sort\nlist.sort([func])\n排序。可选择默认排序或指定排序。会改变原列表。\nwords = [\u0026#39;study\u0026#39;,\u0026#39;python\u0026#39;,\u0026#39;is\u0026#39;,\u0026#39;happy\u0026#39;] words_copy = words.copy() words.sort() print(words) # [\u0026#39;happy\u0026#39;, \u0026#39;is\u0026#39;, \u0026#39;python\u0026#39;, \u0026#39;study\u0026#39;] words_copy.sort(key=len, reverse=False) print(words_copy) # [\u0026#39;is\u0026#39;, \u0026#39;study\u0026#39;, \u0026#39;happy\u0026#39;, \u0026#39;python\u0026#39;]   sorted\nsorted(list, [func])\n排序。可指定排序方式。不改变原列表，并返回一个新的列表。\nwords = [\u0026#39;study\u0026#39;,\u0026#39;python\u0026#39;,\u0026#39;is\u0026#39;,\u0026#39;happy\u0026#39;] words_sort = sorted(words, key=len) print(words) #[\u0026#39;study\u0026#39;, \u0026#39;python\u0026#39;, \u0026#39;is\u0026#39;, \u0026#39;happy\u0026#39;] print(words_sort) #[\u0026#39;is\u0026#39;, \u0026#39;study\u0026#39;, \u0026#39;happy\u0026#39;, \u0026#39;python\u0026#39;]   clear\nlist.clear()\n清空列表，长度变为0。\n  copy\nlist.copy()\n复制一个新的列表。\n  元组 元组与列表类似，不同之处在于元组的元素不能被修改。用逗号分隔的元素自动被创建为元组。\nname = \u0026#39;aa\u0026#39;, \u0026#39;bb\u0026#39;, 1 print(type(name)) #\u0026lt;class \u0026#39;tuple\u0026#39;\u0026gt; empty = (1) print(type(empty)) #\u0026lt;class \u0026#39;int\u0026#39;\u0026gt; print(empty) #1 empty = (1,) print(type(empty)) #\u0026lt;class \u0026#39;tuple\u0026#39;\u0026gt; print(empty) #(1,) tuple 函数 将序列转成元组。\ntuple = tuple(list)\n元组的基本操作 访问元组 tuple[index] 可访问该角标的元组元素。\n并可以使用分片的语法，与 list 相同。\n修改元组 元素值不允许被修改，但可以进行元组连接组合操作。\nname = \u0026#39;aa\u0026#39;, \u0026#39;bb\u0026#39;, 1 single = (1,) print(name + single) #(\u0026#39;aa\u0026#39;, \u0026#39;bb\u0026#39;, 1, 1) 删除元组 元组中的元素值不允许被删除，但可以删除整个元组。\ndel single print(single) #NameError: name \u0026#39;single\u0026#39; is not defined 元组内置函数  len(tuple) max(tuple) min(tuple) tuple(list)  列表与元组的区别 列表可变，元组不可变。因此能使用元组的时候尽量使用元组。\n如果一个元组中包含一个列表，则列表的变化是可以的，因为指向列表的地址未变。\n字符串 字符串的基本操作 由于字符串是不可变的，因此无法分片赋值。\n字符串格式化 字符串格式化符号    符号 描述     %c 格式化字符及其 ASCII 码   %s 格式化字符串   %d 格式化整数   %u 格式化无符号整形   %o 格式化无符号八进制数   %x 格式化无符号十六进制数   %X 格式化无符号十六进制数（大写）   %f 格式化浮点数字，可指定精度值，默认 6 位   %e 用科学计数法格式化浮点数   %E 作用同%e   %g 在保证六位有效数字的前提下，使用小数方式，否则使用科学计数法。   %G 作用同%g   %p 用十六进制数格式化变量的地址    print(\u0026#39;小智今年%s岁了\u0026#39;% 10) #小智今年10岁了 print(\u0026#39;小智今年%d岁了\u0026#39;% 10) #小智今年10岁了 print(\u0026#39;小智今年%f岁了\u0026#39;% 10) #小智今年10.000000岁了 print(\u0026#39;小智今年%u岁了\u0026#39;% 10) #小智今年10岁了 print(\u0026#39;小智今年%e岁了\u0026#39;% 10) #小智今年1.000000e+01岁了 print(\u0026#39;小智今年%E岁了\u0026#39;% 10) #小智今年1.000000E+01岁了 print(\u0026#39;小智今年%g岁了\u0026#39;% 10) #小智今年10岁了 print(\u0026#39;小智今年%G岁了\u0026#39;% 10) #小智今年10岁了 说明（优先级按顺序）：\n  %\n标记转换说明符的开始\n  转换标志（可选）\n-表示对齐；\n+ 表示加上正负号；\n 表示正数之前保留空格；\n0表示转换值位数不够时用 0 填充。\n  最小字段宽度（可选）\n转换后的字符串至少应该具有该宽度。如果是 *，宽度会从值元组中读出。\n  精度值（可选）\n.精度值\n如果转换的是实数，精度值表示出现在小数点后的位数\n如果转换的是字符串，该数字就表示最大字段宽度\n如果是 *,精度从元组中读出\n  转换类型，见上表。\n  print(\u0026#39;第一名是%-s，得分%+d；第二名是%s，得分% d；第三名是%s，得分%0f\u0026#39;%(\u0026#39;甲\u0026#39;, 91, \u0026#39;乙\u0026#39;, 37, \u0026#39;丙\u0026#39;, 21.1)) #第一名是甲，得分+91；第二名是乙，得分 37；第三名是丙，得分21.100000 print(\u0026#39;第一名是%-5s，得分%+*d；第二名是%s，得分% 10.3f；第三名是%s，得分%0.*f\u0026#39;%(\u0026#39;甲\u0026#39;,5, 91, \u0026#39;乙\u0026#39;, 37, \u0026#39;丙\u0026#39;,2, 21.1)) #第一名是甲 ，得分 +91；第二名是乙，得分 37.000；第三名是丙，得分21.10 当既要格式化字符串，又要输出百分号时，要在需输出的百分号前再加一个百分号。\nprint(\u0026#39;法国的控球时间占了%.2f%%\u0026#39;% 54.7897) #法国的控球时间占了54.79 % 字符串格式化元组 当原字符串中有多个参数需要被格式化时，右参数得是个元组，且元组中得有足够的参数填入字符串，否则会报错。\nsentence = \u0026#39;第一名是%s，得分%d；第二名是%s，得分%d。\u0026#39; print(sentence%(\u0026#39;甲\u0026#39;, 91, \u0026#39;乙\u0026#39;, 37)) #第一名是甲，得分91；第二名是乙，得分37。 print(sentence%\u0026#39;甲\u0026#39;, 91, \u0026#39;乙\u0026#39;, 37) #TypeError: not enough arguments for format string print(sentence%(\u0026#39;甲\u0026#39;, 91, \u0026#39;乙\u0026#39;)) #TypeError: not enough arguments for format string 字符串方法 find() 用于检测字符串中是否包含某子字符串。\nindex = original_str.find(child_str, beg=开始角标,end=结束角标)\n没有找到则返回 -1。查找角标包左不包右\nstr = \u0026#39;012345\u0026#39; print(str.find(\u0026#39;4\u0026#39;, 0, 4)) #-1 join() 将字符串序列中的元素以指定字符连接成一个新的字符串。\nstr.join(sequence)\nstr = \u0026#39;012345\u0026#39; print(str.join(\u0026#39;,\u0026#39;)) #, print(\u0026#39;,\u0026#39;.join(str)) #0,1,2,3,4,5 dirs = \u0026#39;\u0026#39;,\u0026#39;home\u0026#39;,\u0026#39;data\u0026#39;,\u0026#39;hdfs\u0026#39; print(\u0026#39;路径为：\u0026#39;, \u0026#39;/\u0026#39;.join(dirs)) #路径为： /home/data/hdfs join 操作的调用和被调用对象都应是字符串或字符序列。\nlower() 把字符串中所有大写字母转成小写。不改变原对象。\nstr.lower()\nupper() 同上，转成大写。\nswapcase() 大小写互转。\nreplace() 把字符串中的 old 替换成 new，如果指定 max，则替换次数不超过 max。不改变原对象。\nstr.replace(old, new[, max])\nsplit() 通过指定分隔符对字符串进行切片，如果指定 num，则最多只分隔成 num 个子字符串，返回一个 list。\nstr.split(st=' ', num=string.count(str))\n默认用空格分隔，能分隔几个就分隔几个。\nstrip() 移除字符串头尾指定字符，默认是空格。\nstr.strip([chars])\ntranslate() 用指定的表转换字符串的字符。\nstr.translate(table)\nintab = \u0026#39;abcde\u0026#39; outtab = \u0026#39;ABCDE\u0026#39; trantab = str.maketrans(intab,outtab) print(type(trantab)) #\u0026lt;class \u0026#39;dict\u0026#39;\u0026gt; original = \u0026#39;hello world\u0026#39; print(original.translate(trantab), \u0026#39;,\u0026#39;, original) #hEllo worlD , hello world 字典 字典是 Python 中唯一内建的映射类型，字典指定值没有特殊顺序，都存储在一个特殊的键里，键可以是数字、字符串、元组。\n创建和使用字典 创建：\nd = {key1:value1,key2:value2} # 空字典 d = {} 键必须是唯一的。\n键必须是不可变的——数字、字符串、元组。\nNone 可以为键。\ndict 可以用 dict 函数，通过其他映射 （如其他字典）或键值序列对建立字典。\nstudent = [[\u0026#39;name\u0026#39;,\u0026#39;甲\u0026#39;],[\u0026#39;score\u0026#39;, 68]] detail = dict(student) print(detail) #{\u0026#39;name\u0026#39;: \u0026#39;甲\u0026#39;, \u0026#39;score\u0026#39;: 68} print(detail[\u0026#39;name\u0026#39;]) #甲 detail = dict(name = \u0026#39;乙\u0026#39;, score = 55) print(detail) #{\u0026#39;name\u0026#39;: \u0026#39;乙\u0026#39;, \u0026#39;score\u0026#39;: 55} print(detail[\u0026#39;score\u0026#39;]) #55 字典的基本操作 修改字典 dict[key] = value 相当于 Java 的 put 操作\nletters = {\u0026#39;a\u0026#39;: 1, \u0026#39;b\u0026#39;: 2, \u0026#39;c\u0026#39;: 3} letters[\u0026#39;d\u0026#39;] = 4 #添加 letters[\u0026#39;a\u0026#39;] = 0 #修改 print(letters) # {\u0026#39;a\u0026#39;: 0, \u0026#39;b\u0026#39;: 2, \u0026#39;c\u0026#39;: 3, \u0026#39;d\u0026#39;: 4} 删除字典 del dict[key] 删除字典的一个 key\ndel dict 删除整个字典\nlen() len(dict) 得到字典的键的总数。\n字典的格式化字符串 print(\u0026#39;a的值是：%(a)s\u0026#39; % letters) #a的值是：0 字典和列表的区别 dict 的特点是：\n 查找和插入快，不会随着 key 增加而变慢； 需要占用大量内存。  list 的特点是：\n 查找和插入的时间随着元素的增加而增加； 占用空间小。  字典方法 clear() dict.clear()\n删除字典内的所有项。删除的是原字典的项而不是指向一个新的字典。\nx = {} y = x x[\u0026#39;key\u0026#39;] = 1 print(y) #{\u0026#39;key\u0026#39;: 1} x.clear() # y所指向的字典的值被清空 print(y) #{} x[\u0026#39;key\u0026#39;] = 2 x = {} # x指向了一个新的字典对象 print(y) #{\u0026#39;key\u0026#39;: 2} copy() dict.copy()\n返回一个具有相同键值对的新字典。\n这是一个浅复制，即值对象原地修改，复制出来的字典也会受影响。\nfromkeys() dict.fromkeys(seq[,value])\n创建一个新字典，以 seq 的值为字典的键，value 的值为字典所有键的初始值。默认字典的 value 都是 None。\nstudent = [\u0026#39;a\u0026#39;, \u0026#39;b\u0026#39;, \u0026#39;c\u0026#39;] print(dict.fromkeys(student)) #{\u0026#39;a\u0026#39;: None, \u0026#39;b\u0026#39;: None, \u0026#39;c\u0026#39;: None} print(dict.fromkeys(student, \u0026#39;default\u0026#39;)) #{\u0026#39;a\u0026#39;: \u0026#39;default\u0026#39;, \u0026#39;b\u0026#39;: \u0026#39;default\u0026#39;, \u0026#39;c\u0026#39;: \u0026#39;default\u0026#39;} get() dict.get(key[, default=None])\n返回指定键的值，如果值不在字典中，返回 default 值。default 值默认为 None。\nin key in dict\n返回一个 boolean 值，表示该字典中有没有这个 key。\nitems() dict.items()\n以列表返回可遍历的（键, 值）元组数组。\n相当于 Java 中的 map.entrySet()。\nletters = {\u0026#39;a\u0026#39;: 1, \u0026#39;b\u0026#39;: 2, \u0026#39;c\u0026#39;: 3} print(letters.items()) #dict_items([(\u0026#39;a\u0026#39;, 1), (\u0026#39;b\u0026#39;, 2), (\u0026#39;c\u0026#39;, 3)]) keys() dict.keys()\n以列表的形式返回一个字典里的所有键。\n相当于 Java 中的 map.keySet()。\nsetdefault() dict.setdefault(key[, default = None])\n与 get() 相似，返回 key 的值，若不存在则以返回 default 的值，default 默认为 None；\n与 get() 不同的是，若字典中不存在这个键，则将 default 的值赋给它。\nletters = {\u0026#39;a\u0026#39;: 1, \u0026#39;b\u0026#39;: 2, \u0026#39;c\u0026#39;: 3} print(letters.get(\u0026#39;d\u0026#39;, 5)) #5 print(letters) #{\u0026#39;a\u0026#39;: 1, \u0026#39;b\u0026#39;: 2, \u0026#39;c\u0026#39;: 3} print(letters.setdefault(\u0026#39;d\u0026#39;, 5)) #5 print(letters) #{\u0026#39;a\u0026#39;: 1, \u0026#39;b\u0026#39;: 2, \u0026#39;c\u0026#39;: 3, \u0026#39;d\u0026#39;: 5} update() dict1.update(dict2)\n把字典 dict2 中的键值对放至 dict1 中。\ndict1 改变，dict2 不变。\nletters = {\u0026#39;a\u0026#39;: 1, \u0026#39;b\u0026#39;: 2, \u0026#39;c\u0026#39;: 3, \u0026#39;d\u0026#39;: 4} updateletters = {\u0026#39;d\u0026#39;: 5, \u0026#39;e\u0026#39;: 6} letters.update(updateletters) print(updateletters) #{\u0026#39;d\u0026#39;: 5, \u0026#39;e\u0026#39;: 6} print(letters) #{\u0026#39;a\u0026#39;: 1, \u0026#39;b\u0026#39;: 2, \u0026#39;c\u0026#39;: 3, \u0026#39;d\u0026#39;: 5, \u0026#39;e\u0026#39;: 6} values() dict.values()\n以列表的形式返回字典中所有值。\n相当于 Java 中的 map.values()。\n条件、循环和其他语句 import 的使用 import 语句 一个 import 可导入多个模块，模块间用逗号分隔。\nfrom math import pi 从模块中导入指定部分到当前命名空间中，不会将 math 整个模块导入。这样可以直接使用变量 pi，而不用按传统的方法写作 math.pi。\n这个写法还可以导入多个变量及方法：from math import pi,sin，并支持通配符 from math import *\n另外可以为模块取别名：import math as m，可以使用m.pi来使用模块的变量和方法。\n或者对单个变量取别名：from math import pi as p，可以使用p来使用该变量。\n使用逗号输出 使用逗号输出会自动格式化。\nprint(\u0026#39;aa\u0026#39;, 1, [\u0026#39;aa\u0026#39;, \u0026#39;bb\u0026#39;], \u0026#39;cc\u0026#39;) #aa 1 [\u0026#39;aa\u0026#39;, \u0026#39;bb\u0026#39;] cc 别样的赋值 序列解包 等号左右两边均有多个以逗号分隔的值/变量 或是序列，则会序列解包分别进行赋值，且没有先后。\nx, y, z = 1, 2, 3 print(x, y, z) #1 2 3 x, y = y, x print(x, y, z) #2 1 3 nums = 1, 2, 3 x, y, z = nums print(x, y, z) # 1 2 3 info = {\u0026#39;name\u0026#39;: \u0026#39;甲\u0026#39;, \u0026#39;mobile\u0026#39;: \u0026#39;13232312333\u0026#39;} a, b = info.popitem() print(a, b) #mobile 13232312333 链式赋值 x = y = z = 10 # 相当于 z = 10 y = z x = y 语句块 同一段语句块中每行语句都要保持相同的缩进。\n在 python 中，:用来标识语句块的开始。\n注意：python 中的语句块和 java 中的不一样，即使语句块外未定义某一个变量，语句块中的变量值语句块外可以直接获取到。\n条件语句 以下值在作为布尔表达值时，会被作为是 false：\n False\tNone\t0\t''\t\u0026quot;\u0026quot;\t()\t[]\t{}\n bool(value)返回 True 和 False。value 可为任何类型。\nif 语句 if 1 == True: print(\u0026#39;1==True\u0026#39;) print(\u0026#39;if end\u0026#39;) # 1==True # if end if 1: print(\u0026#39;1==True\u0026#39;) print(\u0026#39;if end\u0026#39;) # 1==True # if end else 子句 if 0: print(\u0026#39;0==True\u0026#39;) else: print(\u0026#39;0!=True\u0026#39;) print(\u0026#39;if end\u0026#39;) # 0!=True # if end elif 子句 score = 61 if score \u0026gt;= 80: print(\u0026#39;优秀\u0026#39;) elif score \u0026gt;= 60: print(\u0026#39;及格\u0026#39;) else: print(\u0026#39;不及格\u0026#39;) #及格 更多操作   is\n在 Python 中，==相当于 Java 中的 equals()，判断的是值的相等性；\nis相当于 Java 中的==，判断的是是否是同一个对象。\n  比较字符串和序列\n可以对序列进行比较，也能比较嵌套列表。\nprint((1,2) \u0026lt; (2,1)) #True print((1,2) \u0026lt; (1,2,3)) #True print([1,2,[3,4]] \u0026gt; [1,[2,3,4]]) #TypeError: \u0026#39;\u0026gt;\u0026#39; not supported between instances of \u0026#39;int\u0026#39; and \u0026#39;list\u0026#39; print([1,2,[4]] \u0026lt; [1,2,[3,4]]) #False   布尔运算符\nscore = 61 if score \u0026gt;= 80: print(\u0026#39;优秀\u0026#39;) if score \u0026gt;= 60 and score \u0026lt; 80: print(\u0026#39;及格\u0026#39;) if score \u0026lt; 60: print(\u0026#39;不及格\u0026#39;) #及格   断言 score = 61 assert score \u0026gt; 80, \u0026#39;分数小于80，程序出错\u0026#39; #AssertionError: 分数小于80，程序出错 循环 while 循环 i = 1 result = \u0026#39;\u0026#39; while i \u0026lt; 10: result += str(i) i += 1 print(result) #123456789 for 循环 for iterating_var in sequence:\n相当于 Java 中的 foreach。\n可以遍历字符串、列表，也可以遍历字典。默认遍历字典的 key。\nfor letter in \u0026#39;shit\u0026#39;: print(letter) #s #h #i #t for num in [1, 2, 3]: print(num) #1 #2 #3 for key in {\u0026#39;name\u0026#39;: \u0026#39;Lily\u0026#39;, \u0026#39;age\u0026#39;: 64}: print(key) #name #age for key, value in {\u0026#39;name\u0026#39;: \u0026#39;Lily\u0026#39;, \u0026#39;age\u0026#39;: 64}.items(): print(key, \u0026#34;-\u0026#34;, value) #name - Lily #age - 64 items() 将键值对作为元组返回。\n迭代工具 并行迭代 letters = (\u0026#39;a\u0026#39;, \u0026#39;b\u0026#39;, \u0026#39;c\u0026#39;) nums = (1, 2, 3) for i in range(len(letters)): print(letters[i], nums[i]) #等效于 for letter, num in zip(letters, nums): print(letter, num) zip()可以组合两个序列，并且以短序列为准。当短序列遍历结束时，for 循环遍历就会结束。\nprint(type(zip(letters, nums))) #\u0026lt;class \u0026#39;zip\u0026#39;\u0026gt; print(zip(letters, nums)) #\u0026lt;zip object at 0x0000016177F3EAC8\u0026gt; 跳出循环 break num = 10 while num \u0026gt; 0: if num % 7 == 0: break print(num) num -= 1 #10 #9 #8 continue num = 10 while num: if num % 3: num -= 1 continue print(num) num -= 1 #9 #6 #3 循环中的 else 子句 while 中的 else 当 while 的条件为 false 时，执行 else。前提是循环不是因为 break 而终止的\nnum = 1 while num: num -= 1 else: print(\u0026#39;一句只要不break就会打印的话\u0026#39;) print(\u0026#39;end\u0026#39;) # 一句只要不break就会打印的话 # end for 中的 else 基本同上。\npass 语句 是空语句，作用是保持程序结构的完整性。\ncount = 10 if count \u0026gt; 30 : print(\u0026#34;\u0026gt;30\u0026#34;) elif count \u0026gt;= 10 : else: print(\u0026#34;\u0026lt;10\u0026#34;) # IndentationError: expected an indented block # 语法校验错误 count = 10 if count \u0026gt; 30 : print(\u0026#34;\u0026gt;30\u0026#34;) elif count \u0026gt;= 10 : pass else: print(\u0026#34;\u0026lt;10\u0026#34;) print(\u0026#34;end\u0026#34;) #end 练习：猜数游戏 import random result = random.randint(1, 100) count = 0 guess = 0 while count \u0026lt; 10: print(\u0026#39;还剩%s次猜测机会\u0026#39; % (10 - count)) guess = input(\u0026#34;请输入您的猜测数字：\u0026#34;) if not guess.isdigit(): print(\u0026#39;请输入数字\u0026#39;) continue guess = int(guess) count += 1 if guess == result: print(\u0026#34;猜对了！正确答案是%s，您用了%s次猜到了正确答案\u0026#34; % (result, count)) break elif guess \u0026lt; result: print(\u0026#34;您猜低了一点点哦！\u0026#34;) else: print(\u0026#34;您猜高了一点点哦！\u0026#34;) else: print(\u0026#39;机会用完了，请下次再来\u0026#39;) 函数 调用函数 给函数起别名：\nabs_copy = abs print(abs_copy(-1)) #1 定义函数  函数代码块以 def 关键词开关，后接函数标识名称和圆括号。 所有传入的参数和自变量都必须放在圆括号中，可以在圆括号中定义参数。 函数的第一行语句可以选择性使用文档字符串，用于存放文档说明。 函数内容以冒号开始，并且要缩进。 return 结束函数，选择性返回一个值给调用方。不带表达式的 return 相当于返回 None。所以 return None 可以简写为 return。 函数名必须以字母开头，可以包括下划线。  def add_num(a, b): print(a + b) return add_num(1, 2) #3 函数的参数 调用函数时可以使用以下的参数类型：\n 必须参数 关键字参数 默认参数 可变参数 组合参数  必须参数 必须参数必须以正确的顺序传入函数。调用时数量必须和声明时一样。\n关键字参数 使用关键字参数允许调用函数时参数的顺序与声明时不一致。\ndef person_info(name, mobile): print(\u0026#39;name =\u0026#39;, name) print(\u0026#39;mobile =\u0026#39;, mobile) return person_info(mobile=123, name=\u0026#39;Jim\u0026#39;) # name = Jim # mobile = 123 默认参数 调用函数时，如果 没有传递参数，就会使用默认参数。\ndef printmobile(mobile = 123): print(mobile) return printmobile(321) #321 printmobile() #123 调用注意：\n 默认参数必须放在非默认参数之后。 若要更改某个默认参数值，又不想传入其他参数，且该默认参数的位置不是第一个，则可以通过传入关键字参数的方式修改默认值。 若有一个默认参数以关键字参数的方式修改默认值，则其他要修改的默认值也得以关键字参数的方式传入。  可变参数 参数前带 * 的参数就是可变参数，可以传入不定数量个参数。\n* 的参数当作元组来处理，** 当作字典来处理。\n不传就是个空元组/字典。\ndef group(group_name, *person_names): print(type(person_names)) for name in person_names: group_name += (\u0026#39; %s\u0026#39; % name) print(group_name) return group(\u0026#39;SHD\u0026#39;) # \u0026lt;class \u0026#39;tuple\u0026#39;\u0026gt; # SHD group(\u0026#39;SHD\u0026#39;, \u0026#39;Geguri\u0026#39;, \u0026#39;Ado\u0026#39;, \u0026#39;Fearless\u0026#39;, \u0026#39;Sky\u0026#39;, \u0026#39;Diya\u0026#39;, 130, [\u0026#39;freefeel\u0026#39;, \u0026#39;#\u0026#39;]) # \u0026lt;class \u0026#39;tuple\u0026#39;\u0026gt; # SHD Geguri Ado Fearless Sky Diya 130 [\u0026#39;freefeel\u0026#39;, \u0026#39;#\u0026#39;] # 双*示范 def group(person, **person_info): print(type(person_info)) for key,value in person_info.items(): person += (\u0026#39; %s=%s\u0026#39; % (key,value)) print(person) return persons = {\u0026#39;Geguri\u0026#39;:\u0026#39;D.Va\u0026#39;, \u0026#39;Fearless\u0026#39;:\u0026#39;Winston\u0026#39;} group(\u0026#39;Geguri\u0026#39;, character=persons[\u0026#39;Geguri\u0026#39;]) #Geguri character=D.Va 组合参数 自动按序匹配参数类型。\n不能定义两个同类型的可变参数。传入不同的参数类型时，不可穿插，要按顺序来。\ndef exp(p1, p2, df=0, *vart, **kw): print(\u0026#39;p1=\u0026#39;, p1, \u0026#39;p2=\u0026#39;, p2, \u0026#39;df=\u0026#39;, df, \u0026#39;vart=\u0026#39;, vart, \u0026#39;kw=\u0026#39;, kw) exp(1,2) #p1= 1 p2= 2 df= 0 vart= () kw= {} exp(1,2,c=3) #p1= 1 p2= 2 df= 0 vart= () kw= {\u0026#39;c\u0026#39;:3} exp(1,2,3,\u0026#39;a\u0026#39;,\u0026#39;b\u0026#39;) #p1= 1 p2= 2 df= 3 vart= (\u0026#39;a\u0026#39;,\u0026#39;b\u0026#39;) kw= {} exp(1,2,3,\u0026#39;abc\u0026#39;,x=9) #p1= 1 p2= 2 df= 3 vart= (\u0026#39;abc\u0026#39;) kw= {\u0026#39;x\u0026#39;:9} def exp(*tupleparam, **dictparam): print(\u0026#39;tuple\u0026#39;, tupleparam) print(\u0026#39;dict\u0026#39;, dictparam) return exp(\u0026#39;a\u0026#39;, b=3, 7, c=6) #SyntaxError: positional argument follows keyword argument def exp2(*tupleparam1, *tupleparam2): pass #SyntaxError: invalid syntax 变量作用域 全局变量 如果我们定义了一个名为 num 的全局变量，在函数体中也定义了一个名为 num 的局部变量，函数中默认使用局部变量。\n如果需要在函数中把某个变量定义为全局变量，则需要在被定义的变量前加关键字 global。\nnum = 1 def test_global1(): num = 2 return def test_global2(): global num num = 2 # 不可以写成 global num = 2，需先定义全局变量 return test_global1() print(num) #1 test_global2() print(num) #2 返回函数 一个函数的返回值可以是一个函数。\ndef outer(is_plus): def plus(a, b): return a + b def reduce(a, b): return a - b if is_plus: return plus return reduce plus_function = outer(True) print(plus_function) #\u0026lt;function outer.\u0026lt;locals\u0026gt;.plus at 0x00000206260C9EA0\u0026gt; print(plus_function(3, 1)) #4 reduce_function = outer(False) print(reduce_function) #\u0026lt;function outer.\u0026lt;locals\u0026gt;.reduce at 0x00000206260EF048\u0026gt; print(reduce_function(3, 1)) #2 闭包（Closure）：如果在一个内部函数里对外部函数（非全局作用域）的变量进行引用，内部函数就被认为是闭包。\n个人理解：一个函数把另一个函数作为一个工具包返回给了调用方。\n同样的函数，每次返回的闭包都是一个新的函数对象（即使函数入参一样）。\n讲个鬼故事：\ndef count(): fs = [] for i in range(1, 4): def square(): return i*i fs.append(square) return fs f1,f2,f3 = count() print(f1(), f2(), f3()) #9 9 9 执行顺序：for 循环中先挨个把工具函数放到了列表中，放完以后才执行计算，此时 i = 3。\n匿名函数 lambda 的语法：\nlambda 参数[, 参数2] : 表达式\n#=====方法1======= def custom(in_list): return_list = [] for param in in_list: if param \u0026gt; 3: return_list.append(param) return return_list print(custom([1, 2, 3, 4, 5])) #=====方法2======= def bigger_than3(x): return x \u0026gt; 3 result_list = filter(bigger_than3, [1, 2, 3, 4, 5]) print([item for item in result_list]) #=====方法3======= result_list = filter(lambda x: x \u0026gt; 3, [1, 2, 3, 4, 5]) print([item for item in result_list]) #=====方法4======= print([item for item in filter(lambda x: x \u0026gt; 3, [1, 2, 3, 4, 5])]) item for item in filter 是 filter 类的取值方式。filter 函数返回一个 filter 对象——一个迭代器。filter 函数的参数：一个返回值为 bool 的函数对象，以及一个可迭代对象。\n# 无参数 lambda t = lambda : 1 print(t()) #1 # 多参数 lambda plus = lambda a,b : a + b print(plus(1,2)) #3 # 默认参数 lambda default_value = lambda a, b = 1 : a + b print(default_value(2, 2), default_value(2)) #4 3 偏函数 带有第一个参数默认值的新函数 = partial(原函数, 函数的第一个参数)\nimport functools def result_score(total_score, minus_score): return total_score - minus_score remain_score_of_100 = functools.partial(result_score, 100) print(remain_score_of_100(30)) remain_score_of_1000 = functools.partial(result_score, 1000) print(remain_score_of_1000(700)) # 以上等价于↓↓↓↓ def result_score(minus_score, total_score = 100): return total_score - minus_score print(result_score(30)) def result_score2(minus_score, total_score = 1000): return total_score - minus_score print(result_score(700)) 其实就是给函数了一个默认值，只不过变化起默认值来更简单方便。\n面向对象编程 类的定义与使用 类的定义 class MyClass(object): i = 123 def func(self): return \u0026#39;hello world\u0026#39;, self.i  类名驼峰，首字母大写； 类名后的括号表示继承哪个类，不写默认为 object  类的使用 class MyClass(): i = 123 def func(self): return \u0026#39;hello world\u0026#39;, self.i my_class = MyClass() my_class.i = 10 print(my_class.func()) # (\u0026#39;hello world\u0026#39;, 10) 深入类 类的构造方法 __init__([param]) 是一个类的构造函数，默认构造函数规则与 Java 相同。\n与 Java 不同的是，当一个类中重载多个构造方法时，Python 只使用最后那个构造方法，实际上无法「重载」。\n类的访问权限 在 Python 中，类的成员变量可以不做声明，调用方想怎么用就怎么用。\nclass MyClass(): def __init__(self, i): self.i = i print(\u0026#39;带i参数的init\u0026#39;) def func(self): return \u0026#39;hello world\u0026#39;, self.i my_class = MyClass(1) my_class.i = 10 print(my_class.func()) 当实例的变量名以__开头时，则它是一个私有变量，只有内部可以访问。\n讲个鬼故事：\nclass MyClass(): def __init__(self, i): self.__i = i print(\u0026#39;带i参数的init\u0026#39;) def func(self): return \u0026#39;hello world\u0026#39;, self.__i my_class = MyClass(1) #带i参数的init print(my_class.__i) #报错 my_class.__i = 10 print(my_class.__i) #10 print(my_class.func()) #(\u0026#39;hello world\u0026#39;, 1) 关于这个问题，个人的理解是这样的：\n 对象中有个私有变量 __i，在构造对象时初始化为1； 直接调用该对象的私有变量，报错； 将 10 赋个一个名叫「my_class.__i」的变量，该变量与 my_class 对象及其成员变量无关； 最后，这个「my_class.__i」的变量的值为 10，但对象中的 __i 的值仍是 1。  Python 中的 getter 和 setter:\nclass MyClass(): def __init__(self, i): self.__i = i print(\u0026#39;带i参数的init\u0026#39;) def get_i(self): return self.__i def set_i(self, i): self.__i = i my_class = MyClass(1) print(\u0026#39;原i\u0026#39;, my_class.get_i()) #原i 1 my_class.set_i(2) print(\u0026#39;新i\u0026#39;, my_class.get_i()) #新i 2 私有方法：\nclass MyClass(): def __init__(self, i): self.__i = i print(\u0026#39;带i参数的init\u0026#39;) def __func(self): return \u0026#39;hello world\u0026#39;, self.__i my_class = MyClass(1) my_class.__func() #AttributeError: \u0026#39;MyClass\u0026#39; object has no attribute \u0026#39;__func\u0026#39; 继承 Python 的继承有以下特点：\n 基类的构造方法不会被自动调用，需要在子类的构造方法中专门调用； 调用基类方法时需要加上基类的类名前缀，并带上 self 参数变量； 在子类中找不到对应的方法，才到基类中逐个查找。  class Animal(): def __init__(self): print(\u0026#39;animal init\u0026#39;) def running(self): print(\u0026#39;animal is running\u0026#39;) class Cat(Animal): def __init__(self, name): self.name = name print(\u0026#39;cat init\u0026#39;) def running(self): print(\u0026#39;cat is running\u0026#39;) cat = Cat(\u0026#39;Chee\u0026#39;) # 只打印了 cat init，印证基类构造方法不会被自动调用 cat.running() # cat is running Animal.running(cat) # animal is running，重写方法的父类方法的调用方式 另外，需要的时候，基类方法会用到子类对象属性：\nclass Animal(): def __init__(self): print(\u0026#39;animal init\u0026#39;) def running(self): print(\u0026#39;animal %sis running\u0026#39; % self.name) class Cat(Animal): def __init__(self, name): self.name = name print(\u0026#39;cat init\u0026#39;) def running(self): print(\u0026#39;cat is running\u0026#39;) cat = Cat(\u0026#39;Chee\u0026#39;) #cat init Animal.running(cat) #animal Chee is running 个人理解，这里面用到的父类的方法，相当于一个打包好的方法，然后用子类的对象去提供方法中需要用到的参数。\n多态 class Animal(): def running(self): print(\u0026#39;animal %sis running\u0026#39; % self.name) class Cat(Animal): def __init__(self, name): self.name = name print(\u0026#39;cat init\u0026#39;) def running(self): print(\u0026#39;cat is running\u0026#39;) def let_animal_run(animal): animal.running() cat = Cat(\u0026#39;Chee\u0026#39;) let_animal_run(cat) # cat is running 特别说明一下isinstance方法，isinstance(子类对象, 父类) ==\u0026gt; true，instance(父类对象, 子类) ==\u0026gt; false。\n多重继承 Python 可以继承多个类，当父类方法冲突时，以类声明的第一个父类去找，并且找第一个父类的父类……直到找到为止。若第一个父类的所有父类都没有该方法，则找第二个父类。\nclass Animal(): def drink(self): print(\u0026#39;animal drink\u0026#39;) class Wolf(Animal): pass class Person(): def drink(self): print(\u0026#39;person drink\u0026#39;) class WolfPerson(Wolf, Person): pass wolf_person = WolfPerson() wolf_person.drink() # animal drink 获取对象信息 type() import types def func(): pass type(func) == types.FunctionType # True type(abs) == types.BuiltinFunctionType # True type(lambda x: x) == types.LambdaType # True type((x for x in range(10))) == types.GeneratorType #True dir() dir(对象) 返回一个字符串的 list，内容是这个对象的所有属性和方法。\n类的专有方法 __str__() 即 Java 中的 toString()。\n只有在命令行中，对象的显示默认调用 __repr__()。\n__iter__() 即 Java 中的 iterator()。返回一个迭代对象。\n如果想将一个类用于 for\u0026hellip;in 循环，就必须实现该方法。该方法返回一个迭代对象， for 循环时，会先调用 __inter__()方法得到一个迭代器，然后会不断调用该迭代对象的 __next__()方法，直到遇到 StopIteration 错误时退出循环。\n#斐波那契数列输出 class Fib(): def __init__(self): self.a, self.b = 0, 1 def __iter__(self): return self def __next__(self): self.a, self.b = self.b, self.a + self.b if self.a \u0026gt; 100: raise StopIteration() return self.a fib = Fib() for f in fib: print(f) __getitem__() 像 list 一样按照下标取出元素，需要实现__getitem__()方法。\nclass Fib(): def __getitem__(self, item): a, b = 0, 1 for i in range(item + 1): a, b = b, a + b return a fib = Fib() print(fib[2]) __getattr__() 若实现了该方法，则当外部获取对象不存在的属性时不会报错，而会按该方法的定义返回。\nclass Cat(): def __getattr__(self, attr): if attr == \u0026#39;name\u0026#39;: return \u0026#39;chee\u0026#39; return \u0026#39;abc\u0026#39; cat = Cat() print(cat.name) #chee print(cat.age) #abc __call__() 类如果实现了该方法，就直接可以对实例进行方法调用，对象名()这样写就是调用 call 方法了。\nclass Cat(): def __init__(self, name): self.name = name def __call__(self): if self.name == \u0026#39;chee\u0026#39;: print(\u0026#39;麻~~~~\u0026#39;) else: print(\u0026#39;喵~~~~\u0026#39;) chee = Cat(\u0026#39;chee\u0026#39;) chee() #麻~~~~ callable(对象)返回对象类是否实现了__call__()方法。\n异常 异常处理 def exp_exception(a, b): try: return a/b except Exception: print(\u0026#39;catch exception\u0026#39;) return 0 print(exp_exception(1, 0)) # catch exception # 0 抛出异常 Python 使用 raise 语句抛出一个指定异常（即 throw）。\nPython 中的重要内建异常类\n   异常名称 描述     Exception 常规错误的基类   AttributeError 对象没有这个属性   IOError 输入/输出流操作失败   IndexError 序列中没有此索引   KeyError 映射中没有这个键   NameError 未声明/初始化对象（没有属性）   SyntaxError Python 语法错误   ValueError 传入无效参数   SystemError 一般解释器系统错误    def param_validate(a): if a \u0026lt; 0 or a == 0: raise ValueError(\u0026#39;a must be larger than 0\u0026#39;) print(\u0026#39;function do sth\u0026#39;) param_validate(-1) #ValueError: a must be larger than 0 捕捉多个异常 def param_validate(a, b): try: if a \u0026lt; 0 or a == 0: raise ValueError(\u0026#39;a must be larger than 0\u0026#39;) print(a/b) except ValueError: print(\u0026#39;ValueError\u0026#39;) except ZeroDivisionError: print(\u0026#39;ZeroDivisionError\u0026#39;) param_validate(-1, 0) #ValueError param_validate(1, 0) #ZeroDivisionError 使用一个块捕捉多个异常 def param_validate(a, b): try: if a \u0026lt; 0 or a == 0: raise ValueError(\u0026#39;a must be larger than 0\u0026#39;) print(a/b) except (ValueError, ZeroDivisionError): print(\u0026#39;ValueError or ZeroDivisionError\u0026#39;) except ZeroDivisionError: print(\u0026#39;ZeroDivisionError\u0026#39;) param_validate(-1, 0) #ValueError or ZeroDivisionError param_validate(1, 0) #ValueError or ZeroDivisionError 捕捉对象 def param_validate(a, b): try: if a \u0026lt; 0 or a == 0: raise ValueError(\u0026#39;a must be larger than 0\u0026#39;) print(a/b) except (ValueError, ZeroDivisionError) as e: print(e) param_validate(-1, 0) #a must be larger than 0 param_validate(1, 0) #division by zero 全捕捉 def param_validate(a, b): try: if a \u0026lt; 0 or a == 0: raise ValueError(\u0026#39;a must be larger than 0\u0026#39;) print(a/b) except: print(\u0026#39;some error happend\u0026#39;) param_validate(-1, 0) #some error happend param_validate(1, 0) #some error happend 异常中的 else try: do_sth() except Exception: do_sth() else: 若 try 块没有发生异常则执行 自定义异常 class MyError(Exception): def __init__(self, error_msg): self.error_msg = error_msg def __str__(self): return \u0026#39;MyError:%s\u0026#39; % self.error_msg def try_to_raise_my_error(): try: raise MyError(\u0026#39;test my error\u0026#39;) except MyError as e: print(e) try_to_raise_my_error() #MyError:test my error finally 子句 与 Java 中的使用方式一致。\n日期和时间 日期和时间 时间戳 时间戳是一个经加密后形成的凭证文档，包括 3 部分：\n 需加时间戳的文件的摘要 digest； DTS 收到文件的日期和时间； DTS 的数字签名。  struct_time 元组 struct_time 元组一共有 9 个元素：年、月、日、时、分、秒、一年中第几周、一年中第几天、是否为夏令时。\n   序号 属性 字段 值     0 tm_year 4位数年 2018   1 tm_mon 月 1~12   2 tm_mday 日 1~31   3 tm_hour 小时 0~23   4 tm_min 分钟 0~59   5 tm_sec 秒 0~61（60或61是闰秒）   6 tm_wday 一周的第几日 0~6   7 tm_yday 一年的第几日 1~366   8 tm_isdst 是否为夏令时 -1/0/1    time 模块 time() 返回一个当前时间的时间戳。\ntime.time()，第一个 time 表示 time 模块。\nimport time print(time.time()) # 1534055376.9822946 localtime([secs]) 格式化时间戳为本地时间。不传参则以当前时间为标准。\nnow = time.localtime() print(type(now)) #\u0026lt;class \u0026#39;time.struct_time\u0026#39;\u0026gt; print(now[0]) #2018 gmtime([secs]) 将一个时间戳转换为 UTC 时区（0 时区）的 struct_time。默认当前时间。\nmktime(t) 接收 struct_time 对象作为参数，返回用秒数表示时间的浮点数。\nt = (2018, 8, 12, 16, 4, 5, 6, 224, 0) print(time.mktime(t)) #1534061045.0 asctime([t]) 接收时间元组并返回一个可读形式的 24 个字符的字符串。\nprint(time.asctime()) #Sun Aug 12 16:07:27 2018 ctime([secs]) 把时间戳转化为一个可读形式的 24 个字节的字符串\nprint(time.ctime()) #Sun Aug 12 16:11:04 2018 sleep(secs) 挂起线程运行的时间。\nprint(\u0026#39;start:\u0026#39;, time.localtime()[5]) time.sleep(3) print(\u0026#39;end\u0026#39;, time.localtime()[5]) # start: 50 # end 53 clock() 以浮点数计算的秒数返回当前 CPU 时间，用来衡量不同程序的耗时。精度高。\n time.clock has been deprecated in Python 3.3 and will be removed from Python 3.8: use time.perf_counter or time.process_time instead\n 使用 perf_counter 来计算执行时间：\ndef sleep_time(secs): start_time = time.perf_counter() time.sleep(secs) print(time.perf_counter() - start_time) sleep_time(2) sleep_time(2) #2.0002070240000003 #2.000590122 strftime(format[,t]) 接收时间元组，并返回以可读字符串表示的当地时间，格式由参数 format 决定。\ndef str_format_time(t): return time.strftime(\u0026#39;%Y-%m-%d%H:%M:%S\u0026#39;, t) print(str_format_time(time.localtime())) #2018-08-12 16:34:52 strptime(string[, format]) 把一个指定格式的时间字符串解析为时间元组。\nprint(time.strptime(\u0026#39;2018-08-12 16:34:52\u0026#39;, \u0026#39;%Y-%m-%d%H:%M:%S\u0026#39;)) #time.struct_time(tm_year=2018, tm_mon=8, tm_mday=12, tm_hour=16, tm_min=34, tm_sec=52, tm_wday=6, tm_yday=224, tm_isdst=-1) 三种时间格式转化 graph TB C1(struct_time) C2(Format string) C3(Timestamp) C1--strftime--\u0026gt;C2 C2--strptime--\u0026gt;C1 C1--mktime--\u0026gt;C3 C3--localtime/gmtime--\u0026gt;C1 C4(%a %b %d %H %M:%S %Y 串) C1--asctime--\u0026gt;C4 C3--ctime--\u0026gt;C4 datetime 模块 datetime 支持 0001 年（datetime.MINYEAR）到 9999 年（datetime.MAXYEAR）。\n此模块定义了以下 5 个类：\n datetime.date： 表示日期的类。常用属性：year、month、day。 datetime.time：表示时间的类。常用属性：hour、minute、second、microsecond。 datetime.datetime：表示日期时间。 datetime.timedelta：表示时间间隔。 datetime.tzinfo：与时区有关的相关信息。  datetime.datetime today() 返回一个表示当前本地时间的 datetime 对象。\nnow([tz]) 可选入参 timezone 时区，如果不输入参数，则 now() 和 today() 没什么区别。\nutcnow() 返回一个当前 UTC 时间的 datetime对象。\nfromtimestamp(timestamp[, tz]) 根据时间戳创建一个 datetime 对象。\nutcfromtimstamp(timestamp) 根据当前 UTC 时间和时间戳创建一个 datetime 对象。\nstrptime(date_string, format) 将格式字符串转换为 datetime 对象。\nstrftime(format) 将 datetime 对象转换为格式化的 str。\n日历模块  calendar.calendar(year, w=2, l=1, c=6)  该函数返回一个多行字符串格式的 year 年历，3 个月一行。\nw-每日间隔宽度\nl-星期间隔行数\nc-月间隔宽度\n  calendar.firstweekday()\n返回当前每周起始日期的设置，默认为 0（周一）。可使用 setfirstweekday() 修改，之后使用 calendar 的 api 都为修改后的设置。\n  calendar.isleap(year)\n是否是闰年\n  calendar.leapdays(y1,y2)\ny1 和 y2 两年之间的闰年的总数\n  calendar.month(year,month,w=2,l=1)\n返回一个多选字符串格式的 year 年 month 月日历。\n  calendar.monthcalendar(year,month)\n返回一个整数的单层嵌套列表。\nprint(calendar.monthcalendar(2018,8)) # [[0, 0, 0, 1, 2, 3, 4], [5, 6, 7, 8, 9, 10, 11], [12, 13, 14, 15, 16, 17, 18], [19, 20, 21, 22, 23, 24, 25], [26, 27, 28, 29, 30, 31, 0]]   calendar.monthrange(year,month)\n返回一个元组，内有两个值。\n第一个是这个月是从周几开始的，第二个是这个月共有几天。\n  calendar.timegm(tupletime)\n和 time.gmtime 相反，接收一个时间元组形式，返回该时刻的时间戳。\n  calendar.weekday(year,month,day)\n返回这一天是周几。\n  文件操作 打开文件 open(file_name[, access_mode][, buffering])\nfile_name:文件名；\naccess_mode:打开模式，只读/写入/追加 等。默认为只读(r)；\nbuffering:寄存区缓冲大小。\nfile_name 可为绝对路径也可为相对路径，绝对路径写全地址，相对路径用.代替当前路径值，..代替父路径。\naccess_mode 值说明：\n'r' open for reading (default) 'w' open for writing, truncating the file first 'x' create a new file and open it for writing 'a' open for writing, appending to the end of the file if it exists 'b' binary mode 't' text mode (default) '+' open a disk file for updating (reading and writing) 基本文件方法 读和写 读：file_content = fileObject.read([count]) count 参数表示读多少。默认读所有。\n写：write_length = fileObject.write(string)\n读写行 readline file.readline([count]) count 表示读多少字符。默认读指针开始这一行的所有内容。\n# 文件内容如下： # 123 # 456 # 789 file = open(\u0026#39;test.txt\u0026#39;) print(file.readline(1)) # 1 print(file.readline(5)) # 123 个人推测 readline() 的 count 参数的算法为：\n count 小于等于 0 时，不生效； 前面若没有换行符，则截至当前位置。 其余情况，均只读一行  readlines list = file.readlines([hint]) hint 表示读取长度。值小于等于 0 或不传则读所有。\n# 文件内容如下： # 123 # 456 # 789 file = open(\u0026#39;test.txt\u0026#39;) print(file.readlines(1)) # [\u0026#39;123\\n\u0026#39;] print(file.readline(5)) # [\u0026#39;123\\n\u0026#39;, \u0026#39;456\\n\u0026#39;] writelines 即 readlines 的反向。换行符不能省。\n关闭文件 fileObject.close()\n文件重命名 引入 os 包，如果在重命名操作前对 file 进行了 open 操作并且未 close，则会报错 PermissionError。\nimport os os.rename(\u0026#39;e:/code/python/test01.txt\u0026#39;, \u0026#39;e:/code/python/test02.txt\u0026#39;) 删除文件 if os.path.exists(\u0026#39;e:/code/python/test01.txt\u0026#39;): # if 判断，避免抛错 print(\u0026#39;file exist\u0026#39;) os.remove(\u0026#39;e:/code/python/test01.txt\u0026#39;) else: print(\u0026#39;file not exist\u0026#39;) 文件迭代 # 文件内容如下： # 123 # 456 # 789 # 方法一：fileinput 不用手动开关文件 import fileinput count = 0 for line in fileinput.input(\u0026#39;e:/code/python/test01.txt\u0026#39;): count += 1 print(\u0026#39;line\u0026#39;, count) print(line) # 结果 # line 1 # 123 # # line 2 # 456 # # line 3 # 789 # 存在的空行个人认为是原文本最后的\u0026#39;\\n\u0026#39;换行字符在控制台解析后的结果 # 方法二：文件迭代器 文件本身就可迭代，方便 file = open(\u0026#39;e:/code/python/test01.txt\u0026#39;) count = 0 for line in file: count += 1 print(\u0026#39;line\u0026#39;, count) print(line) file.close() # 结果同上 两种方法是完全等价的。\nStringIO 函数 用途：操作 String 的另一种方法。\nfrom io import StringIO # 写入值 # 1.new 对象时写入 io_object = StringIO(\u0026#39;aa\u0026#39;) # 2.通用的 IO 写入 io_object.write(\u0026#39;bb\u0026#39;) io_object.writelines([\u0026#39;\\nbb\\ncc\u0026#39;, \u0026#39;dd\u0026#39;]) # 输出 # 1.获取这个流种的所有的值，指针不会动 io_object.getvalue() # 2.通用的 IO 读取 list = io_object.readlines() 序列化和反序列化 一般序列化和反序列化 引入 pickle 模块。\n序列化：\npickle.dump(obj, file[, protocol])\nimport pickle # dumps 的应用 dumps_obj = pickle.dumps(\u0026#39;123\u0026#39;) print(dumps_obj) #b\u0026#39;\\x80\\x03X\\x03\\x00\\x00\\x00123q\\x00.\u0026#39; print(type(dumps_obj)) #\u0026lt;class \u0026#39;bytes\u0026#39;\u0026gt; # dump 的应用 # 1. 打开这个待写的文件 student_file = open(\u0026#39;student.txt\u0026#39;, \u0026#39;wb\u0026#39;) # 2. 生成待写的对象 xiao_ming = dict(name=\u0026#39;xiaoming\u0026#39;, age=12) students = [] students.append(xiao_ming) # 3. 序列化输出到文件 pickle.dump(students, student_file) # 4. 关闭文件 student_file.close() 反序列化：\nstudent_file = open(\u0026#39;student.txt\u0026#39;, \u0026#39;rb\u0026#39;) students = pickle.load(student_file) print(students) #[{\u0026#39;name\u0026#39;: \u0026#39;xiaoming\u0026#39;, \u0026#39;age\u0026#39;: 12}] student_file.close() JSON 序列化和反序列化  json.dumps() 序列化 json.loads() 反序列化  # 关于 dumps students_dumps = json.dumps(students) print(students_dumps) #[{\u0026#34;name\u0026#34;: \u0026#34;xiaoming\u0026#34;, \u0026#34;age\u0026#34;: 12}] print(type(students_dumps)) #\u0026lt;class \u0026#39;str\u0026#39;\u0026gt; # 序列化 file_object = open(\u0026#39;student.txt\u0026#39;, \u0026#39;w\u0026#39;) json.dump(students, file_object) file_object.close() # 反序列化 file_object = open(\u0026#39;student.txt\u0026#39;) json_object = json.load(file_object) file_object.close() print(json_object) #[{\u0026#39;name\u0026#39;: \u0026#39;xiaoming\u0026#39;, \u0026#39;age\u0026#39;: 12}] print(type(json_object)) #\u0026lt;class \u0026#39;list\u0026#39;\u0026gt; with 自己加的，书里没写到（这么好用的东西竟然不写，真的是。。。）\nwith open(\u0026#39;student.txt\u0026#39;) as file_object: aa = json.load(file_object) print(aa) #[{\u0026#39;name\u0026#39;: \u0026#39;xiaoming\u0026#39;, \u0026#39;age\u0026#39;: 12}] print(type(aa)) #\u0026lt;class \u0026#39;list\u0026#39;\u0026gt; ","date":"2018-07-17T21:23:54+08:00","permalink":"/post/2018-07-17-python3.5%E5%AD%A6%E4%B9%A0/","title":"python3.5学习"},{"content":"Redis 内存模型深入\nRedis 内存统计  使用redis-cli -h {hostname} -p {port}连接 redis 连接成功，使用info memory查看内存信息  used_memory:9451784 #分配器分配的内存总量 used_memory_human:9.01M #上一行的人类看得懂的方式 used_memory_rss:12984320 #Redis进程占据操作系统的内存 used_memory_rss_human:12.38M used_memory_peak:19658408 used_memory_peak_human:18.75M used_memory_peak_perc:48.08% used_memory_overhead:7657748 used_memory_startup\u0026quot;1424544 used_memory_dataset:1794036 used_memory_dataset_perc:22.35% total_system_memory:16862044160 total_system_memory_human:15.70G used_memory_lua:37888 used_memory_lua_human:37.00K maxmemory:0 maxmemory_human:0B maxmemory_policy:noeviction mem_fragmentation_ratio:1.37 #内存碎片比率 mem_allocator:jemalloc-4.0.3 # 内存分配器 active_defrag_running:0 lazyfree_pending_objects:0  used_memory: Redis 分配的内存总量（包括使用的虚拟内存）； used_memory_rss: Redis 进程占据操作系统的内存，和 top 以及 ps 命令看到的是一样的； 即：used_memory + 进程运行内存 + 内存碎片 - 虚拟内存； mem_fragmentation_ratio: 内存碎片比，即 used_memory_rss/used_memory 。 小于1时说明内存不够用了，使用了虚拟内存； 越大说明内存碎片比越大，内存分配器是 jemalloc 的时候1.03是个较健康的状态。 mem_allocator: 内存分配器。包括jemalloc(default)、libc、tcmalloc。  内存划分  数据 值包括5种对外提供的类型：字符串、哈希、列表、集合、有序集合。\nRedis 内部对每种类型的值可能有2种或更多的内部编码实现。\n数据会统计在 used_memory 中。 进程本身需要的内存 Redis 主进程本身运行，代码、常量池等需要占用的内存。\n不属于内存分配器分配，不会统计在 used_memory，但会统计在 used_memory_rss 中。 缓冲内存 包括客户端缓冲区、复制积压缓冲区、AOF 缓冲区。\n由分配器分配，统计在 used_memory 和 used_memory_rss 中。 内存碎片 内存碎片是 Redis 在分配、回收物理内存过程中产生的。\n如果对数据更改频繁，且数据之间的大小相差很大，会形成内存碎片。\n不统计在 used_memory 中，但会统计在 used_memory_rss 中。\n可以通过安全重启减小内存碎片。  Redis 数据存储细节 概述 当 Redis set hello world 的时候，它干了啥  what Redis have done when set ‘hello world’ \n-\u0026gt; dictEntry 每个键值对都有一个 dictEntry，里面包含指向 key 和 value 的指针；next 指向下一个 dictEntry，与本 key-value 无关。\n-\u0026gt; key 存储于 SDS 结构中\nSDS: struct sdsheader { int len; int free; char buf[]; } -\u0026gt; redisObject 不管什么类型的 value 都存储在 redisObject 中。redisObject 中的 type 字段指明了 value 对象的类型，ptr 指向对象所在地址。而 redisObject 中的字符串对象仍然是通过 SDS 存储的。\n-\u0026gt; jemalloc 以上对象都需要内存分配器分配内存进行存储。\nredisObject redisObject 对象非常重要，Redis 对象的类型、内部编码、内存回收、共享对象等功能，都需要 redisObject 支持。\nredisObject 的定义如下（不同版本的 Redis 可能稍有不同）：\ntypedef struct redisObject { unsigned type:4; unsigned encoding:4; unsigned lru:REDIS_LRU_BITS; int refcount; void *ptr; } robj; 一个 redisObject 对象大小为 16 Bype。\n  type: 对象类型 包括 REDIS_STRING、REDIS_LIST、REDIS_HASH、REDIS_SET、REDIS_ZSET。\n  encoding: 对象的内部编码 每种数据类型都有至少两种 encoding。比如字符串有 int/embstr/raw 这三种。目的是优化性能。\nobject encoding {key} 可查看对象编码方式。\n  lru: 对象最后一次被命令程序访问的时间 当前时间 - 最后访问时间(ms)。\nobject idletime {key} 查看对象空转时间，且不改变对象 lru 值。\n与 Redis 内存回收有关。如果 Redis 打开了 maxmemory 选项，且内存回收算法选择了 volatile-lru 或 allkeys-lru，会优先释放空转时间最长的对象。\n  refcount: 对象引用次数 refcount 主要用于对象的引用计数和内存回收。\n当创建新对象时，refcount 初始化为 1；值为 0 时，则该对象内存被释放。\n多次被引用的对象称为共享对象，目前只支持整数值的字符串对象。\nRedis 服务器在初始化时，会创建 10000 个字符串对象，为 0-9999 的整数值，Redis 可直接使用这些共享对象。\n关于此特性的调优考虑：尽可能使用 0/1 而非 Y/N。\nobject refcount {key} 查看对象 value 引用次数。\n  ptr 数据指针\n指向 value 值。\n  SDS 即简单动态字符串（Simple Dynamic String）的缩写。\n结构 struct sdshdr{ int len; int free; char buf[]; };  buf：字节数组，用来存储字符串； len：buf 已使用的长度； free：buf 未使用的长度。  例：\n  存储一个无 free 的字符串 “Redis” free = 0; len = 5; buf = [\u0026lsquo;R\u0026rsquo;, \u0026lsquo;e\u0026rsquo;, \u0026rsquo;d', \u0026lsquo;i\u0026rsquo;, \u0026rsquo;s', \u0026lsquo;\\0\u0026rsquo;];\n  存储一个有free 的字符串 “Redis” free = 4; len = 5; buf = [\u0026lsquo;R\u0026rsquo;, \u0026lsquo;e\u0026rsquo;, \u0026rsquo;d', \u0026lsquo;i\u0026rsquo;, \u0026rsquo;s', \u0026lsquo;\\0\u0026rsquo;, , , , ];\n  根据以上可知，buf 数组的 length 实际上是 free + len + 1(字符串结尾的空字符)。\n所以一个 SDS 结构数据的长度为 4(free) + 4(len) + buf(free 的值 + len 的值 + 1) = free + len + 9。\nSDS 与 C 字符串的比较 SDS 在 C 字符串的基础上加入了 free 和 len， 好处如下：\n 获取字符串时的计算复杂度 SDS 是 O(1)，C 字符串是 O(n)； 缓存区溢出 C 字符串长度增加而忘记重新分配内存，容易造成缓冲区的溢出；\nSDS 记录了长度，可能会溢出时会自动重新分配内存。 修改字符串时内存的重分配\nC 字符串修改，要重新分配内存（先释放再申请）；\nSDS 可做空间预分配策略，预先进行多余空间的分配，使得重新分配内存的概率减小。 存取二进制数据\nC 字符串不可以，因为用空字符作为字符串结束标识；\nSDS 以长度 len 作为字符串结束标识。\nSDS 中的 buf 仍然使用了 C 字符串，因此 SDS 可以使用 C 字符串库中的部分函数；但只有当 SDS 存储文本数据时才可以这样使用，在存储二进制数据时则不行（‘\\0’不一定是 buf 的结尾）。  SDS 与 C 字符串在 Redis 中的应用 Redis 在存储对象时，包括 key 和不管什么形式的 value，一律使用 SDS。\n各种缓冲区，也使用 SDS。\n只有在字符串不会改变的情况下，如打印日志时，才会使用 C 字符串。\nRedis 的对象类型与内部编码 Redis 3.0 内部编码类型：\n   类型 编码 对象     REDIS_STRING REDIS_ENCODING_INT 使用整数值实现的字符串对象   REDIS_STRING REDIS_ENCODING_EMBSTR 使用 embstr 编码的简单动态字符串实现的字符串对象   REDIS_STRING REDIS_ENCODING_RAW 使用简单动态字符串实现的字符串对象   REDIS_LIST REDIS_ENCODING_ZIPLIST 使用压缩列表实现的列表对象   REDIS_LIST REDIS_ENCODING_LINKEDLIST 使用双端链表实现的列表对象   REDIS_HASH REDIS_ENCODING_ZIPLIST 使用压缩列表实现的哈希对象   REDIS_HASH REDIS_ENCODING_HT 使用字典实现的哈希对象   REDIS_SET REDIS_ENCODING_INTSET 使用整数集合实现的集合对象   REDIS_SET REDIS_ENCODING_HT 使用字典实现的集合对象   REDIS_ZSET REDIS_ENCODING_ZIPLIST 使用压缩列表实现的有序集合对象   REDIS_ZSET REDIS_ENCODING_SKIPLIST 使用跳跃表和字典实现的有序集合对象    字符串 概况 字符串是最基础的类型，所有的键都是字符串类型，且字符串之外的其他几种复杂类型的元素也是字符串（？）。\n字符串长度不能超过 512 MB。\n内部编码  int 8 个字节的长整型。（其实就是 long） embstr \u0026lt;=39 字节的字符串。 raw \u0026gt;39 字节的字符串。   embstr 与 raw 的区别\n都使用 redisObject 和 SDS 保存数据，创建时，embstr 给 redisObject 和 SDS 只分配一次内存空间， raw 需要两次分别给 redisObject 和 SDS 分配空间。\n因此 embstr 创建时少分配一次空间，且地址连续；但如果字符串长度增加需要重新分配内存时，整个 redisObject 和 SDS 都需要重新分配空间，因此 Redis 中的 embstr 实现为只读。  编码转换 int 不再是整数，或大小超出 long 的范围，自动转 raw。\nembstr 由于只读，只要修改 embstr 对象，一定转 raw。\n列表 概况 用来存储多个有序的字符串，每个字符串称为元素；\n一个列表可以存储 2^32-1 个元素；\n支持两端插入和弹出，并可获得指定位置或范围的元素。\n内部编码  双端链表 linkedlist\n由一个 list 结构和多个 listNode 结构组成。\n链表中的所有结点指向的都是 type 为字符串的 redisObject  typedef struct list { //双向链表 包括三个操作函数  listNode *head; // 指向链表头结点  listNode *tail; // 指向链表尾结点  void *(*dup)(void *ptr);//复制函数指针  void (*free)(void *ptr);//释放函数指针  int (*match)(void *ptr, void *key);//匹配函数指针  unsigned long len; //节点计数 } list; 压缩列表 ziplist\n是由一系列特殊编码的连续内存块（而不是像双端链表一样每个节点都是指针）组成的顺序型数据结构。\n与双端链表相比，压缩列表可以节省内存空间，但是进行增删改时复杂度较高。   linkedlist 和 ziplist 的场景 节点多时，使用双端链表划算；节点少时，应使用压缩列表。  编码转换 同时满足以下两个条件使用 ziplist：1）列表元素数量小于 512 个；2）所有字符串对象都不足 64 个字节（单字符串，而非 SDS 结构）。\nziplist 可以转 linkedlist，而 linkedlist 不能转 ziplist。\n哈希 概况 哈希同时也是 Redis 作为 Key-Value 数据库所使用的数据结构，不可混淆。\n内部编码   压缩列表 ziplist 同上。\n优势为集中存储，节省空间。\n  哈希表 hashtable\n   hashtable struct \nRedis 数据库所使用的编码。\n包含 1 个 dict 结构、2 个 dictht 结构 、1 个 dictEntry 指针数组 （即 bucket） 和多个 dictEntry 结构。\n dictEntry\n用于保存键值对  typedef struct dictEntry{ void *key; // 键值对中的键  union{ // 键值对中的值（共同体）  void *val; // 可能是指向型指针  uint64_tu64; // 可能是 64 位整型  int64_ts64; // 可能是无符号 64 位整型  }v; struct dictEntry *next; // 下一个 dictEntry，用于解决哈希冲突 }dictEntry; 在 64 位系统中，一个 dictEntry 对象占 24 字节（key/val/next 各 8 字节）。\n bucket 即一个元素为 dictEntry 结构的数组。\nbucket 数组大小：取大于现有元素数量的最小的 2 的 n 次方。\n如 1000 个 dictEntry 的 bucket 大小为 1024;1100 个 dictEntry 的 bucket 大小为 2048。 dictht  typedef struct dictht{ dictEntry **table; // 指向 bucket  unsigned long size; // bucket 的大小  unsigned long sizemask; // =size-1，和哈希值一起决定一个键在 table 中存储的位置  unsigned long used; // bucket 中已使用的 dictEntry 数量 }dictht;  dict  typedef struct dict{ dictType *type; void *privdata; dictht ht[2]; int trehashidx; } dict; - type \u0026amp; privdata：为了适应不同类型的键值对，用于创建多态字典。\n- ht \u0026amp; trehashidx：用于 rehash，即哈希表的扩展或收缩\n- ht：指向两个 dictht。通常数据存在 ht[0] 中，rehash 时，将 ht[0] 的数据 rehash 到 ht[1] 中，然后将 ht[1] 赋值给 ht[0]，最后清空 ht[1]。\ndict 主要是用于适应不同类型的键值对以及 rehash。\n编码转换 转换规则与列表相似。\n同时满足以下两个条件使用 ziplist：1）哈希中元素数量小于 512 个；2）哈希中所有键和值字符串长度都不足 64 个字节。\nziplist 可以转 hashtable，而 hashtable 不能转 ziplist。\n集合 set 概况 集合与列表类似，都是用来保存多个字符串。\n与列表的区别：\n 集合中的元素是无序的，因此不能通过索引来操作元素 集合中的元素不能重复  一个集合最多可以存储 2^32-1 个元素。\n除了支持常规的增删改查，还支持多个集合取交集、并集、差集。\n内部编码  哈希表 hashtable 字典的每个键都是一个字符串对象， 每个字符串对象包含了一个集合元素， 而字典的值则全部被设置为 NULL。\n其余同前，略。 整数集合 intset  typedef struct intset{ uint32_t encoding; // contents 存储类型  uint32_t length; // 元素个数  int8_t contents[]; } intset; encoding 的说明：虽然 contents 是 int8_t 类型，但实际上其存储的值是 int16_t、int32_t 或 int64_t，由 encoding 决定。\n整数集合适用于集合所有元素都是整数且集合元素数量较小的时候，优势在于集中存储，节省空间；虽然对于元素操作复杂度也由 O(1) 变为了 O(n)，但集合数量少的时候操作的时间并没有明显劣势。\n编码转换 同时满足以下两个条件则使用整数集合：1）集合中的元素数量小于 512 个；2）集合中所有元素都是整数值。\n整数集合可转为哈希表，哈希表不能转为整数集合。\n有序集合 概况 与集合一样，元素都不能重复；\n与集合不同，元素是有顺序的；\n与列表不同，不以索引下标作为排序依据，而为每个元素设置一个分数（score）作为排序依据。\n内部编码 压缩列表（ziplist）或跳跃表（skiplist）。\n  ziplist\n略。\n  skiplist\n是一种有序数据结构，通过在每个节点中维持多个指向其他节点的指针，达到快速访问节点的目的。\n支持平均 O(logN)、最坏 O(N) 的复杂度进行节点查找，并支持顺序操作。\nRedis 的跳跃表实现由 zskiplist 和 zskiplistNode 两个结构组成：前者用于保存跳跃表信息（如头结点、尾结点、长度等），后者用于表示跳跃表节点。\n具体结构比较复杂，略。\n  编码转换 同时满足以下两个条件则使用 ziplist：1）元素总量小于 128；2）所有成员长度都不足 64 字节。\n可由 ziplist 转 skiplist，反向则不能。\n应用举例 优化内存占用 利用 jemalloc 特性进行优化 由于 jemalloc 分配内存时数值是不连续的，因此 key/value 变化一个字节，可能会引起占用内存很大的变动。应注意一些特殊值。\n例，如果 key 的长度是 8 字节，则 SDS 为 17 字节（free+len+9），jemalloc 分配 32 字节；而若 key 的长度是 7 字节，则 SDS 为 16 字节，jemalloc 分配 16 字节。\n jemalloc-save-space \n使用整形 如果是整型/长整型，Redis 会使用 int 类型来存储，可节省空间。\n共享对象 利用共享对象，可以减少对象的创建，节省内部空间。\n使用 0-9999 这些整数，或可通过调整 REDIS_SHARED_INTEGERS 参数提高共享对象的个数。\n关注内存碎片率 内存碎片率过高（标准为 1.03）时，内存碎片多，可考虑重启 Redis。\n碎片率小于 1，则机器内存不足，可考虑拓展机器。\n 本文参考自 编程迷思博客\n ","date":"2018-04-28T17:49:00+08:00","permalink":"/post/2018-04-28-redis-%E5%86%85%E5%AD%98%E6%A8%A1%E5%9E%8B%E6%B7%B1%E5%85%A5/","title":"Redis 内存模型深入"},{"content":"基本概念  mongodb 中文网站：www.mongoing.com mongodb 中文文档：docs.mongoing.com nosql 数据库相比传统 sql 数据库少了：实时一致性；事务；多表联合查询。 杀掉 MongoDB 的进程需使用kill -15或不带参数，不能使用kill -9  MongoDB 相比于其他 nosql 数据库的优点  相较于 redis 而言，可以提供复杂结构的数据存储，而 redis 只有简单的键值对存储； 相较于 hbase 的单索引，MongoDB 的索引更灵活，支持单键索引、多键索引、数组索引、全文索引。  基础操作   创建并使用一个库：use test\n  展示所有库：show dbs\n  插入一条数据（并新建一个集合\u0026ndash;相当于表的概念）：db.my_collection.insert({num:1})\n  展示所有集合：show collections\n  查询集合所有内容：db.my_collection.find()\n  条件查询：db.my_collection.find({num:2})\n  JS 语法循环插入：for(i=1;i\u0026lt;=100;i++)db.my_collection.insert({num:i})\n  查询数量：db.my_collection.find().count()\n  查询跳过：.skip(2)\n  查询限制条数：.limit(2)\n  查询排序：.sort({num:1}) 1即asc，-1即desc\n  全字段更新：.update({num:1}, {num:999})\n第一个参数是查找属性，第二个参数修改后属性\n当多条数据满足查找条件时，仅更新第一条\n  部分字段更新：.update({num:1}, {$set:{age:88}})\n  插入或更新：.update({num:1}, {age:88}, true) 当查询条件不存在时，就创建一条\n  更新所有查到的数据：.update({num:1}, {$set:{age:88}}, false, true)\n这种情况只允许部分字段更新，不允许更新或插入模式。\n  删除数据：.remove({num:1})\n  删除集合：db.my_collection.drop()\n  查询索引：.getIndexes()\n  创建索引：.ensureIndex({num:1}) 1即asc，-1即desc\n  常见索引 _id索引 默认自动建立的索引\n单键索引 创建：.ensureIndex({num:1})\n重复创建时，MongoDB 会直接返回成功\n多键索引 如果索引字段为一个数组，则为多键索引\n复合索引 即联合索引\n创建：.ensureIndex({num:1, age:1})\n过期索引 一段时间后会过期的索引。\n 索引过期后，相应数据会被删除。 索引字段必须是 ISODate 或 ISODate 数组，不能使用时间戳，否则不能被自动删除。 索引字段如果是 ISODate 数组，则按照最快到时的时间进行删除。 过期索引不能是复合索引。 删除时间不精确。由后台程序每 60s 跑一次。  插入 ISODate 数据：.insert({num:1, age:88, time:new Date()})\n创建：.ensureIndex({time:1}, {expireAfterSeconds:10})\n全文索引 对字符串与字符串数组创建全文可搜索的索引\n每个集合只能有一个全文索引\n创建单个键的全文索引：.ensureIndex({title:\u0026quot;text\u0026quot;})\n创建多个键的全文索引：.ensureIndex({title:\u0026quot;text\u0026quot;, article:\u0026quot;text\u0026quot;})\n对所有键创建全文索引：.ensureIndex({\u0026quot;$**\u0026quot;:\u0026quot;text\u0026quot;})\n使用全文索引查询：.find({$text:{$search:\u0026quot;coffee\u0026quot;}})\n或查询：.find({$text:{$search:\u0026quot;coffee cola tea\u0026quot;}})\n非查询，加-即为排除该字段：.find({$text:{$search:\u0026quot;coffee cola -tea\u0026quot;}})\n与查询，加双引号表示一定得有它：.find({$text:{$search:\u0026quot;\\\u0026quot;coffee\\\u0026quot; \\\u0026quot;cola\\\u0026quot; \\\u0026quot;tea\\\u0026quot;\u0026quot;}})\n全文索引相似度：\n.find({$text:{$search:\u0026quot;coffee cola\u0026quot;}}, {my_score:{$meta:\u0026quot;textScore\u0026quot;}})\n全文索引相似度并排序：\n.find({$text:{$search:\u0026quot;coffee cola\u0026quot;}}, {my_score:{$meta:\u0026quot;textScore\u0026quot;}}).sort(my_score:{$meta:\u0026quot;textScore\u0026quot;}})\n全文索引的限制：\n 每次查询，只能指定一个 $text 查询 $text 查询不能出现在 $nor 查询中 查询中如果包含了 $text，那么 hint 不再起作用 不支持中文  索引属性 索引命名：\nMongoDB 有一套默认的索引命名方式，为了直观可以自行命名索引：\n.ensureIndex({num:1, age:1}, {name:\u0026quot;my_normal_index\u0026quot;})\n地理位置索引 ","date":"2017-10-17T21:26:54+08:00","permalink":"/post/2017-10-17-mongodb%E5%9F%BA%E7%A1%80%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%E6%9B%B4%E6%96%B0%E4%B8%AD/","title":"mongodb基础学习笔记（更新中）"},{"content":"其实非常不喜欢被称作是“程序媛”，仿佛是被独立在“程序员”之外的一个物种，就像女博士和女司机一样。\n女性程序员根本就没有传说中那么稀有。但人们说起程序员，仿佛就默认他是个男人，这令人十分不愉快。\n下周就要去迪士尼了，脐带。\n","date":"2017-09-21T15:33:54+08:00","permalink":"/post/2017-09-21-%E5%96%B5/","title":"喵"},{"content":"基础知识 字符串  单引号和双引号是一个意思，三个引号被用于长短的文字或者说明 字符串+数字 会报错 字符串*数字 表示显示几遍的意思  # 字符串 乘以 数字 word = \u0026#34;words\u0026#34; * 3 print(word) # wordswordswords words = \u0026#39;a loooooong word\u0026#39; num = 12 string = \u0026#39;bang!\u0026#39; total = string * (len(words) - num) print(total) # bang!bang!bang!bang!  字符串分片 字符串的分片实际上可以看作是把字符串的一部分截取出来，复制储存在另一个地方（相当于是个副本），不会对原字符串做改动。\n分片时的字符串index，正数是从0开始从前往后数，负数是从-1开始从后往前数\n截取的时候与java的substring一样——包左不包右\n# 字符串分片 birthDay = \u0026#39;happy birth day to you\u0026#39; print(birthDay[0]) # h print(birthDay[-3]) # y print(birthDay[11:14]) # da print(birthDay[5:]) # birth day to you print(birthDay[:5]) # happy print(birthDay[-5:5]) # 啥都不输出，也不报错  基本运算    ： 加。有一个元素为浮点，结果为浮点；     ： 减。同上     ： 乘。同上   / ： 除以。有一个元素为浮点，结果为浮点；除不尽的情况下，即使两个都是整，结果也是浮点；有浮点的精度问题； ** ： 幂。有一个元素为浮点，结果为浮点； % ： 模。有一个元素为浮点，结果为浮点；有浮点的精度问题； //： 整除。有一个元素为浮点，结果为浮点。  math_calc(19.9, 0.1) # 加 20.0 # 减 19.799999999999997 # 乘 1.99 # 除以 198.99999999999997 # 幂 1.34860668348221 # 模 0.09999999999999748 # 整除 198.0 逻辑判断  多条件比较  middle = 5 print(1 \u0026lt; middle \u0026lt; 10) # True    字符串比较\n相当于 java 中的 String.equals 方法，在 python 中可以直接用 == 来判断\n  不同类型的比较\n除了整数和浮点类型之间以外，不同类型对象不能使用“\u0026lt;, \u0026gt;, \u0026lt;=, \u0026gt;=”来判断。\n所有类型对象之间均能使用“==, !=”来判断。\n整数和浮点类型的判断，与数学常识相同。\n  对象本身判断 在python中，任何对象都可以用bool(对象)的方式来进行判断，只有以下情况结果为false: 0，None，空字符串，空集合，false布尔值。\n  判断字符 not x : 即取反。 x and y : 且。 x or y : 或。\n  if-elif-else def account_login_reset(store_password): password = input(\u0026#39;input password:\u0026#39;) is_correct = password == store_password[-1] is_reset = password == store_password[0] if is_correct: print(\u0026#39;login success\u0026#39;) elif is_reset: new_password = input(\u0026#39;input new password:\u0026#39;) store_password.append(new_password) print(\u0026#39;reset success!login again\u0026#39;) account_login_reset(store_password) else: print(\u0026#39;incorrect password\u0026#39;) account_login_reset(store_password) account_login_reset([\u0026#39;0\u0026#39;, \u0026#39;123456\u0026#39;]) 循环 for every_letter in \u0026#39;hello world\u0026#39;: print(every_letter)  字符串可以被for循环遍历 for...in 相当于 java 中的 foreach  # 打印九九乘法口诀表 def print_nine_nine(): for i in range(1, 10): for j in range(1, i + 1): print(\u0026#39;{} * {} = {}\\t\u0026#39;.format(j, i, i*j), end=\u0026#39;\u0026#39;) print() 集合 list # 创建列表 album = [] # 创建非空列表 album = [\u0026#39;Black Star\u0026#39;, \u0026#39;David Bowie\u0026#39;, 25, True] # 增加元素 album.append(\u0026#39;new song\u0026#39;) # 列表索引 print(album[0], album[-1]) # 打印列表第一个元素和最后一个元素 print(\u0026#39;Black Star\u0026#39; in album) # true，相当于contains print(\u0026#39;David Bowie\u0026#39; not in album) # false # 列表求和 a_list = [1, 2, 3] print(sum(a_list)) # 6 list里的元素求和 自定义函数 # 函数的定义 def fahrenheit_converter (C): return str(C * 9/5 +32) + \u0026#39;F\u0026#39; # 函数的调用 print(fahrenheit_converter(32)) 函数调用时，传参有两种方式：位置传参和参数名传参。两种方式可以混合使用。\ndef triangle_math(lineOne, lineTwo): return (lineOne ** 2 + lineTwo ** 2) ** (1 / 2) # 传参的两种方式 print(\u0026#39;the right triangle third sids\\\u0026#39;s length is {}\u0026#39;.format(str(triangle_math(3, 4)))) print(\u0026#39;2the right triangle third sids\\\u0026#39;s length is {}\u0026#39;.format(str(triangle_math(lineOne=3, lineTwo=4)))) 定义函数的时候，可以设置某个参数有默认值\n# 函数定义默认值 def defaultValue(name=\u0026#39;Sarah\u0026#39;): print(\u0026#39;{name} is a beautiful girl\u0026#39;.format(name = name)) return defaultValue() # Sarah is a beautiful girl defaultValue(\u0026#39;Caro\u0026#39;) # Caro is a beautiful girl 基本函数  type() 用来查看变量的类型 print() 打印 open() 打开文件，第二个参数mode值为\u0026rsquo;w\u0026rsquo;表示写入模式：有则覆盖，无则新建 write() 输出文件 int() 变量类型转换为int str() 变量类型转换为string len(str) 输出字符串长度 str1.find(str2) 在str2中寻找str1的起始位置角标；找不到则为-1  # 查找字符串a在字符串b中的位置 search = \u0026#39;168\u0026#39; num_a = \u0026#39;13861680006\u0026#39; num_b = \u0026#39;16812220006\u0026#39; num_c = \u0026#39;13181542561\u0026#39; print(str(num_a.find(search)) + \u0026#39; to \u0026#39; + str(num_a.find(search) + len(search))) print(str(num_b.find(search)) + \u0026#39; to \u0026#39; + str(num_b.find(search) + len(search))) print(str(num_c.find(search)) + \u0026#39; to \u0026#39; + str(num_c.find(search) + len(search)))  format() 字符串填空 input() 用户输入信息  # 字符串format函数 print(\u0026#39;{} is {}\\\u0026#39;s birthday.\u0026#39;.format(\u0026#39;Today\u0026#39;, \u0026#39;Caro\u0026#39;)) print(\u0026#39;{when} is {name}\\\u0026#39;s birthday.\u0026#39;.format(when = \u0026#39;Today\u0026#39;, name = \u0026#39;Caro\u0026#39;)) print(\u0026#39;{1} is {0}\\\u0026#39;s birthday\u0026#39;.format(\u0026#39;Caro\u0026#39;, \u0026#39;Today\u0026#39;))  range(left_num, right_num) 集合，包括 left_num 到 right_num 的元素，包左不包右  基本规则  为防止中文注释乱码或报错，可在文件开头加一行魔法注释：#coding:utf-8  ","date":"2017-07-22T00:09:54+08:00","permalink":"/post/2017-07-22-python%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%E6%9B%B4%E6%96%B0%E4%B8%AD/","title":"python学习笔记（更新中）"},{"content":"[root@fbgouhuaapp01 java]# alternatives --install /usr/bin/java java /usr/local/java/jdk1.8.0_121/bin/java 2 [root@fbgouhuaapp01 java]# alternatives --config java There is 1 program that provides \u0026#39;java\u0026#39;. Selection Command ----------------------------------------------- *+ 1 /usr/local/java/jdk1.8.0_121/bin/java Enter to keep the current selection[+], or type selection number: 1 [root@fbgouhuaapp01 java]# alternatives --install /usr/bin/jar jar /opt/jdk1.8.0_121/bin/jar 2 [root@fbgouhuaapp01 java]# alternatives --install /usr/bin/javac javac /opt/jdk1.8.0_121/bin/javac 2 [root@fbgouhuaapp01 java]# alternatives --set jar /opt/jdk1.8.0_121/bin/jar [root@fbgouhuaapp01 java]# alternatives --set javac /opt/jdk1.8.0_121/bin/javac [root@fbgouhuaapp01 java]# java --version  ","date":"2017-07-14T17:41:54+08:00","permalink":"/post/2017-07-14-%E7%BB%BF%E8%89%B2%E7%89%88jdk%E5%AE%89%E8%A3%85%E6%89%A7%E8%A1%8C%E5%91%BD%E4%BB%A4/","title":"绿色版jdk安装执行命令"},{"content":"什么时候不使用shell  大量数据处理任务，尤其是当要求速度时（排序、哈希、递归）。 涉及重型数学运算（使用 C++ 或 FORTRAN 来替代）。 需要跨平台（使用 C 或 Java 替代）。 需要结构化编程的复杂应用程序（变量的类型检查，函数原型等）。 非常非常关键性的任务。 当需要确保安全性时。 项目由具有互锁依赖性的子组件组成。 需要大量文件操作（Bash仅限于串行文件访问，且它的逐行执行方式笨拙并低效）。 需支持多维数组。 需支持数据结构。 需生成/操纵图形或 GUI。 需要直接访问系统硬件或外部外围设备。 需要端口或 socket I/O。 需要使用库或历史代码生成的接口。 专有的封闭源代码应用程序。  一个简单的栗子：清理脚本 #!/bin/bash # Proper header for a Bash script. # Cleanup, version 2 # Run as root, of course. # Insert code here to print error message and exit if not root. LOG_DIR=/var/log # Variables are better than hard-coded values. cd $LOG_DIR # cat /dev/null \u0026gt; file 即把 file 放入垃圾箱，并给 file 赋空值 cat /dev/null \u0026gt; messages cat /dev/null \u0026gt; wtmp echo \u0026#34;Logs cleaned up.\u0026#34; exit # The right and proper method of \u0026#34;exiting\u0026#34; from a script. # A bare \u0026#34;exit\u0026#34; (no parameter) returns the exit status #+ of the preceding command.  特殊字符  # : 注释该字符至行尾 ; : 命令分隔符。允许将两个或多个命令放在同一行上。 ;; : 终止一个 case 的选项  case \u0026#34;$variable\u0026#34; in abc) echo \u0026#34;\\$variable = abc\u0026#34; ;; xyz) echo \u0026#34;\\$variable = xyz\u0026#34; ;; esac   单引号 vs 双引号\n单引号里的任何字符都会原样输出，变量无效；\n双引号中可以有变量。\n单引号字符串中不能出现单引号；\n双引号字符串中可以出现转义字符。\n  逗号\n连接两个计算表达式，两个都执行，但只返回后一个。\n  let \u0026#34;t = ((a = 9, 15 / 3))\u0026#34; echo $t echo $a # 输出：5，9  也可以连接字符串。\n# 输出 /bin/*calc 和 /usr/bin/*calc 文件 for file in /{,usr/}bin/*calc # ^ Find all executable files ending in \u0026#34;calc\u0026#34; #+ in /bin and /usr/bin directories. do if [ -x \u0026#34;$file\u0026#34; ] then echo $file fi done # /bin/ipcalc # /usr/bin/kcalc # /usr/bin/oidcalc # /usr/bin/oocalc  插播一个 cat 的功能：\n cat filename : 显示文件内容 cat \u0026gt; filename : 创建新文件 cat file1 file2 \u0026gt; file : 将几个文件合并为一个 cat /dev/null \u0026gt; file : 把 file 放入垃圾箱，并给 file 赋空值  字符串操作 获取字符串长度 string=\u0026#34;abcd\u0026#34;echo ${#string} # 输出：4  提取子字符串 string=\u0026#34;google is a great company\u0026#34; echo ${string:1:4} # 输出：oogl 包左且包右  查找子字符串 string=\u0026#34;google is a great company\u0026#34; echo \u0026#39;expr index \u0026#34;$string\u0026#34; is\u0026#39; # 输出：7 出现的位置角标  if语句 if [ condition1 ] then command1 conmand2 elif [ condition2 ] command3 else command4 fi 注意：方括号前后需加空格。\nif 的条件表达式：\n 文件表达式\n-f file : 如果文件存在\n-d directory : 如果目录存在\n-s file : 文件存在且非空\n-r file : 文件存在且可读(-w -x 同理) 整数变量表达式\na -eq b : 等于\na -ne b : 不等于\na -ge b : 大于等于\na -gt b : 大于\na -le b : 小于等于\na -lt b : 小于 字符串变量表达式\n$a = $b : 等于\n$a != $b\n-z $a : 为空\n$a : 非空 逻辑表达式\n! : 非\n-a : 与\n-o : 或  case语句 case $a in value1) command ;; value2) command ;; esac 判断 -e：判断文件或目录是否存在\n-d：判断是目录，且存在\n-f：判断是普通文件，且存在\n-r -w -x：判断是否有读、写、执行权限\nif [ -e filename ] ;then 循环 ####for\nfor var in item1 item2 ... itemN do command1 command2 done ####c风格的for\nfor (( EXP1; EXP2; EXP3 )) do command1 command2 done ####while\nwhile condition do command done 数学计算 a=1 b=2 sum=$[$a+$b] ","date":"2017-04-02T17:57:54+08:00","permalink":"/post/2017-03-29-shell%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%E6%9B%B4%E6%96%B0%E4%B8%AD/","title":"shell学习笔记（更新中）"},{"content":" 新建一个注释类  @Target(ElementType.METHOD) @Retention(RetentionPolicy.RUNTIME) @Documented public @interface RequestCheck { boolean value() default true; } 新建一个拦截器类  @Aspect @Component public class RequestInterceptor { public Log logger = LogFactory.getLog(this.getClass()); // 拦截开关  @Value(\u0026#34;${common.app.checkAuth}\u0026#34;) private Boolean checkAuth; private static final byte[] userStore = RedisUtil.serialize(\u0026#34;__token_app_userStore\u0026#34;); @Pointcut(\u0026#34;execution(* com.mytest..*.*(..)) \u0026amp;\u0026amp; @annotation(com.mytest.app.util.annotation.RequestCheck)\u0026#34;) private void requestNeedCheck() { } @Before(\u0026#34;requestNeedCheck()\u0026#34;) public void before(JoinPoint joinPoint) throws Throwable { if (!checkAuth) { return; } HttpServletRequest request = ((ServletRequestAttributes) RequestContextHolder.getRequestAttributes()) .getRequest(); String userId = request.getParameter(\u0026#34;userId\u0026#34;); String token = request.getHeader(\u0026#34;access_token\u0026#34;); Object[] args = joinPoint.getArgs(); logger.info(\u0026#34;拦截器userId:\u0026#34; + userId + \u0026#34;, token:\u0026#34; + token); if (!StringUtils.isEmpty(token)) { byte[] key = RedisUtil.serialize(token); String redisUserId = (String) RedisUtil.unserialize(RedisUtil.hget(this.userStore, key)); logger.info(\u0026#34;拦截器redisUserId:\u0026#34; + redisUserId); if (!StringUtils.isEmpty(userId)) { if (!userId.equals(redisUserId)) { throw new RuntimeException(\u0026#34;非法请求:用户token与用户id校验失败\u0026#34;); } } else { for (Object arg : args) { if (arg instanceof Map) { Map\u0026lt;String, Object\u0026gt; params = (Map\u0026lt;String, Object\u0026gt;) arg; String var1 = String.valueOf(params.get(\u0026#34;userId\u0026#34;)); String var2 = String.valueOf(params.get(\u0026#34;user_id\u0026#34;)); logger.info(\u0026#34;拦截器var1:\u0026#34; + var1 + \u0026#34;, var2:\u0026#34; + var2); if (!\u0026#34;null\u0026#34;.equals(var1.toLowerCase()) \u0026amp;\u0026amp; !StringUtils.isEmpty(var1)) { if (!var1.equals(redisUserId)) { throw new RuntimeException(\u0026#34;非法请求:用户token与用户id校验失败\u0026#34;); } } if (!\u0026#34;null\u0026#34;.equals(var2.toLowerCase()) \u0026amp;\u0026amp; !StringUtils.isEmpty(var1)) { if (!var2.equals(redisUserId)) { throw new RuntimeException(\u0026#34;非法请求:用户token与用户id校验失败\u0026#34;); } } } } } } } } 使用注解拦截方法  @RequestMapping(\u0026#34;/test\u0026#34;) @RequestCheck public Map\u0026lt;String, Object\u0026gt; test(String test) { return success(); } ","date":"2017-03-24T10:06:54+08:00","permalink":"/post/2017-03-24-springboot%E4%B8%8B%E6%8B%A6%E6%88%AA%E5%99%A8%E5%AE%9E%E7%8E%B0/","title":"Springboot下拦截器实现"},{"content":"被公司的意式咖啡机惯得，回家喝速溶咖啡，难喝到想吐。\n啊！可是我一个月前刚屯了整整三瓶速溶咖啡啊！\n忧伤脸。\n这个教训说明：因为便宜而屯东西，常常得不偿失。\n以后如果不能常常喝到现磨咖啡，应该会在家里备一个胶囊咖啡机吧！\n","date":"2017-03-20T13:55:54+08:00","permalink":"/post/2017-03-20-%E7%BB%88%E4%BA%8E%E7%90%86%E8%A7%A3%E6%B5%81%E6%98%9F%E8%8A%B1%E5%9B%AD%E4%B8%AD%E5%AB%8C%E5%BC%83%E9%80%9F%E6%BA%B6%E5%92%96%E5%95%A1%E7%9A%84%E5%AF%8C%E5%AE%B6%E5%A5%B3%E4%BA%86/","title":"终于理解流星花园中嫌弃速溶咖啡的富家女了"},{"content":"Java 代码规范 编程规约 命名规则   【强制】抽象类命名使用 Abstract 或 Base 开头；异常类命名使用 Exception 结尾；测试类 命名以它要测试的类的名称开始，以 Test 结尾。\n  【强制】POJO 类中布尔类型的变量，都不要加 is，否则部分框架解析会引起序列化错误。\n反例：定义为基本数据类型 boolean isSuccess；的属性，它的方法也是 isSuccess()，RPC 框架在反向解析的时候，“以为”对应的属性名称是 success，导致属性获取不到，进而抛出异 常。\n  【强制】包名统一使用小写，点分隔符之间有且仅有一个自然语义的英语单词。包名统一使用单数形式，但是类名如果有复数含义，类名可以使用复数形式。\n正例： 应用工具类包名为 com.alibaba.open.util、类名为 MessageUtils（此规则参考 spring 的框架结构）\n  【推荐】接口类中的方法和属性不要加任何修饰符号（public 也不要加），保持代码的简洁 性，并加上有效的 Javadoc 注释。尽量不要在接口里定义变量，如果一定要定义变量，肯定是 与接口方法相关，并且是整个应用的基础常量。\n正例：接口方法签名：void f(); 接口基础常量表示：String COMPANY = \u0026ldquo;alibaba\u0026rdquo;;\n反例：接口方法定义：public abstract void f();\n说明：JDK8 中接口允许有默认实现，那么这个 default 方法，是对所有实现类都有价值的默 认实现。\n  【参考】各层命名规约：\nA) Service/DAO 层方法命名规约\n\u0026ndash;1） 获取单个对象的方法用 get 做前缀。\n\u0026ndash;2） 获取多个对象的方法用 list 做前缀。\n\u0026ndash;3） 获取统计值的方法用 count 做前缀。\n\u0026ndash;4） 插入的方法用 save（推荐）或 insert 做前缀。\n\u0026ndash;5） 删除的方法用 remove（推荐）或 delete 做前缀。\n\u0026ndash;6） 修改的方法用 update 做前缀。\nB) 领域模型命名规约\n\u0026ndash;1） 数据对象：xxxDO，xxx 即为数据表名。\n\u0026ndash;2） 数据传输对象：xxxDTO，xxx 为业务领域相关的名称。\n\u0026ndash;3） 展示对象：xxxVO，xxx 一般为网页名称。\n\u0026ndash;4） POJO 是 DO/DTO/BO/VO 的统称，禁止命名成 xxxPOJO。\n  常量定义  【强制】不允许出现任何魔法值（即未经定义的常量）直接出现在代码中。\n反例： String key=\u0026ldquo;Id#taobao_\u0026quot;+tradeId； cache.put(key, value); 【强制】long 或者 Long 初始赋值时，必须使用大写的 L，不能是小写的 l，小写容易跟数字 1 混淆，造成误解。\n说明：Long a = 2l; 写的是数字的 21，还是 Long 型的 2?  OOP规约  【强制】 Object 的 equals 方法容易抛空指针异常，应使用常量或确定有值的对象来调用equals。\n正例： \u0026ldquo;test\u0026rdquo;.equals(object);\n反例： object.equals(\u0026ldquo;test\u0026rdquo;);\n说明： 推荐使用 java.util.Objects#equals （JDK7 引入的工具类） 【强制】关于基本数据类型与包装数据类型的使用标准如下：\n\u0026ndash;1） 所有的 POJO 类属性必须使用包装数据类型。\n\u0026ndash;2） RPC 方法的返回值和参数必须使用包装数据类型。\n\u0026ndash;3） 所有的局部变量【推荐】使用基本数据类型。\n说明： POJO 类属性没有初值是提醒使用者在需要使用时，必须自己显式地进行赋值，任何 NPE 问题，或者入库检查，都由使用者来保证。\n正例： 数据库的查询结果可能是 null，因为自动拆箱，用基本数据类型接收有 NPE 风险。\n反例： 比如显示成交总额涨跌情况，即正负 x%， x 为基本数据类型，调用的 RPC 服务，调用不成功时，返回的是默认值，页面显示： 0%，这是不合理的，应该显示成中划线-。所以包装数据类型的 null 值，能够表示额外的信息， 如：远程调用失败，异常退出。 【强制】定义 DO/DTO/VO 等 POJO 类时，不要设定任何属性默认值。\n反例： POJO 类的 gmtCreate 默认值为 new Date();但是这个属性在数据提取时并没有置入具体值，在更新其它字段时又附带更新了此字段，导致创建时间被修改成当前时间。 【强制】构造方法里面禁止加入任何业务逻辑，如果有初始化逻辑，请放在 init 方法中。 【强制】 POJO 类必须写 toString 方法。\n说明： 在方法执行抛出异常时，可以直接调用 POJO 的 toString()方法打印其属性值，便于排查问题。 【推荐】使用索引访问用 String 的 split 方法得到的数组时，需做最后一个分隔符后有无 内容的检查，否则会有抛 IndexOutOfBoundsException 的风险。 说明：  String str = \u0026#34;a,b,c,,\u0026#34;; String[] ary = str.split(\u0026#34;,\u0026#34;); //预期大于 3，结果是 3 System.out.println(ary.length);  【推荐】 final 可提高程序响应效率，声明成 final 的情况：\n\u0026ndash;1） 不需要重新赋值的变量，包括类属性、局部变量。\n\u0026ndash;2） 对象参数前加 final，表示不允许修改引用的指向。\n\u0026ndash;3） 类方法确定不允许被重写。  集合处理   【强制】 关于 hashCode 和 equals 的处理，遵循如下规则：\n\u0026ndash;1） 只要重写 equals，就必须重写 hashCode。\n\u0026ndash;2） 因为 Set 存储的是不重复的对象，依据 hashCode 和 equals 进行判断，所以 Set 存储的对象必须重写这两个方法。\n\u0026ndash;3） 如果自定义对象做为 Map 的键，那么必须重写 hashCode 和 equals。\n正例： String 重写了 hashCode 和 equals 方法，所以我们可以非常愉快地使用 String 对象作为 key 来使用。\n  【强制】使用集合转数组的方法，必须使用集合的 toArray(T[] array)，传入的是类型完全一样的数组，大小就是 list.size()。\n反例： 直接使用 toArray 无参方法存在问题，此方法返回值只能是 Object[]类，若强转其它类型数组将出现 ClassCastException 错误。\n正例：\n  List\u0026lt;String\u0026gt; list = new ArrayList\u0026lt;String\u0026gt;(2); list.add(\u0026#34;guan\u0026#34;); list.add(\u0026#34;bao\u0026#34;); String[] array = new String[list.size()]; array = list.toArray(array); 说明： 使用 toArray 带参方法，入参分配的数组空间不够大时， toArray 方法内部将重新分配内存空间，并返回新数组地址； 如果数组元素大于实际所需，下标为[ list.size() ]的数组元素将被置为 null，其它数组元素保持原值，因此最好将方法入参数组大小定义与集合元素个数一致。\n 【强制】不要在 foreach 循环里进行元素的 remove/add 操作。 remove 元素请使用 Iterator 方式，如果并发操作，需要对 Iterator 对象加锁。\n反例：  List\u0026lt;String\u0026gt; a = new ArrayList\u0026lt;String\u0026gt;(); a.add(\u0026#34;1\u0026#34;); a.add(\u0026#34;2\u0026#34;); for (String temp : a) { if(\u0026#34;1\u0026#34;.equals(temp)){ a.remove(temp); } } 说明： 以上代码的执行结果肯定会出乎大家的意料，那么试一下把“1”换成“2”，会是同样的结果吗？\n正例：\nIterator\u0026lt;String\u0026gt; it = a.iterator(); while(it.hasNext()){ String temp = it.next(); if(删除元素的条件){ it.remove(); } } 并发处理  【强制】 SimpleDateFormat 是线程不安全的类，一般不要定义为 static 变量，如果定义为 static，必须加锁，或者使用 DateUtils 工具类。\n正例： 注意线程安全，使用 DateUtils。亦推荐如下处理：  private static final ThreadLocal\u0026lt;DateFormat\u0026gt; df = new ThreadLocal\u0026lt;DateFormat\u0026gt;() { @Override protected DateFormat initialValue() { return new SimpleDateFormat(\u0026#34;yyyy-MM-dd\u0026#34;); } }; 说明： 如果是 JDK8 的应用，可以使用 Instant 代替 Date， LocalDateTime 代替 Calendar，DateTimeFormatter代替Simpledateformatter，官方给出的解释：simple beautiful strong immutable thread-safe。\nString time = DateUtils.formatDate(new Date(), \u0026#34;yyyy-MM-dd\u0026#34;); System.out.println(time);  【推荐】避免 Random 实例被多线程使用，虽然共享该实例是线程安全的，但会因竞争同一 seed 导致的性能下降。\n说明： Random 实例包括 java.util.Random 的实例或者 Math.random()实例。\n正例： 在 JDK7 之后，可以直接使用 API ThreadLocalRandom，在 JDK7 之前，可以做到每个线程一个实例。  int randomInt = ThreadLocalRandom.current().nextInt();  【参考】 ThreadLocal 无法解决共享对象的更新问题， ThreadLocal 对象建议使用 static 修饰。这个变量是针对一个线程内所有操作共有的，所以设置为静态变量，所有此类实例共享此静态变量 ，也就是说在类第一次被使用时装载，只分配一块存储空间，所有此类的对象(只要是这个线程内定义的)都可以操控这个变量。  控制语句  【强制】在一个 switch 块内，每个 case 要么通过 break/return 等来终止，要么注释说明程序将继续执行到哪一个 case 为止； 在一个 switch 块内，都必须包含一个 default 语句并且放在最后，即使它什么代码也没有。 【推荐】除常用方法（如 getXxx/isXxx）等外，不要在条件判断中执行其它复杂的语句，将复杂逻辑判断的结果赋值给一个有意义的布尔变量名，以提高可读性。\n说明： 很多 if 语句内的逻辑相当复杂，阅读者需要分析条件表达式的最终结果，才能明确什么样的条件执行什么样的语句，那么，如果阅读者分析逻辑表达式错误呢？\n正例：  //伪代码如下 boolean existed = (file.open(fileName, \u0026#34;w\u0026#34;) != null) \u0026amp;\u0026amp; (...) || (...); if (existed) { ... } 反例：\nif ((file.open(fileName, \u0026#34;w\u0026#34;) != null) \u0026amp;\u0026amp; (...) || (...)) { ... }  【推荐】循环体中的语句要考量性能，以下操作尽量移至循环体外处理，如定义对象、变量、获取数据库连接，进行不必要的 try-catch 操作（ 这个 try-catch 是否可以移至循环体外）。 【强制】方法内部单行注释，在被注释语句上方另起一行，使用//注释。方法内部多行注释使用/* */注释，注意与代码对齐。  其他  【强制】在使用正则表达式时，利用好其预编译功能，可以有效加快正则匹配速度。 说明： 不要在方法体内定义： Pattern pattern = Pattern.compile(规则);  异常日志 异常处理  【强制】异常不要用来做流程控制，条件控制，因为异常的处理效率比条件分支低。 【强制】对大段代码进行 try-catch，这是不负责任的表现。 catch 时请分清稳定代码和非稳定代码，稳定代码指的是无论如何不会出错的代码。对于非稳定代码的 catch 尽可能进行区分异常类型，再做对应的异常处理。 【强制】不能在 finally 块中使用 return， finally 块中的 return 返回后方法结束执行，不会再执行 try 块中的 return 语句。 【推荐】方法的返回值可以为 null，不强制返回空集合，或者空对象等，必须添加注释充分说明什么情况下会返回 null 值。调用方需要进行 null 判断防止 NPE 问题。\n说明： 本规约明确防止 NPE 是调用者的责任。即使被调用方法返回空集合或者空对象，对调用者来说，也并非高枕无忧，必须考虑到远程调用失败，运行时异常等场景返回 null 的情况。 【推荐】返回类型为包装数据类型，有可能是 null，返回 int 值时注意判空。\n反例： public int f(){ return Integer 对象}; 如果为 null，自动解箱抛 NPE。 【推荐】定义时区分 unchecked / checked 异常，避免直接使用 RuntimeException 抛出，更不允许抛出 Exception 或者 Throwable，应使用有业务含义的自定义异常。推荐业界已定义过的自定义异常，如： DAOException / ServiceException 等。  日志规约  【强制】日志文件推荐至少保存 15 天，因为有些异常具备以“周”为频次发生的特点。 【强制】对 trace/debug/info 级别的日志输出，必须使用条件输出形式或者使用占位符的方式。\n说明： logger.debug(\u0026ldquo;Processing trade with id: \u0026quot; + id + \u0026quot; symbol: \u0026quot; + symbol);\n如果日志级别是 warn，上述日志不会打印，但是会执行字符串拼接操作，如果 symbol 是对象，会执行 toString()方法，浪费了系统资源，执行了上述操作，最终日志却没有打印。\n正例： （条件）  if (logger.isDebugEnabled()) { logger.debug(\u0026#34;Processing trade with id: \u0026#34; + id + \u0026#34; symbol: \u0026#34; + symbol); } 正例： （占位符）\nlogger.debug(\u0026#34;Processing trade with id: {} symbol : {} \u0026#34;, id, symbol); 工程规约 应用分层 【参考】分层领域模型规约：\n DO（ Data Object） ：与数据库表结构一一对应，通过 DAO 层向上传输数据源对象。 DTO（ Data Transfer Object） ：数据传输对象， Service 和 Manager 向外传输的对象。 BO（ Business Object） ：业务对象。 可以由 Service 层输出的封装业务逻辑的对象。 QUERY：数据查询对象，各层接收上层的查询请求。 注：超过 2 个参数的查询封装，禁止使用 Map 类来传输。 VO（ View Object） ：显示层对象，通常是 Web 向模板渲染引擎层传输的对象。  安全规约  【强制】在使用平台资源，譬如短信、邮件、电话、下单、支付，必须实现正确的防重放限制，如数量限制、疲劳度控制、验证码校验，避免被滥刷、资损。\n说明： 如注册时发送验证码到手机，如果没有限制次数和频率，那么可以利用此功能骚扰到其它用户，并造成短信平台资源浪费。  ","date":"2017-03-18T11:10:54+08:00","permalink":"/post/2017-03-18-alibaba-java%E4%BB%A3%E7%A0%81%E8%A7%84%E8%8C%83%E9%83%A8%E5%88%86/","title":"Alibaba: Java 代码规范（部分）"},{"content":"环境中配置了 Eureka ，在发起 HttpClient 请求时，遇到「eureka No instances available for \u0026hellip;」的问题。这是由于发起请求的目标域名在 Eureka 服务器中没有实例。\n查 资料 ，有两种解决办法：\n 不要使用 netflix 这套路由服务（这居然也是一种办法么= =）； 不要使用默认的 RestTemplate 来发起请求，应 new 一个新的 RestTemplate 来操作。  具体实现代码如下：\nJSONObject json = new JSONObject(sendParam); HttpHeaders headers = new HttpHeaders(); MediaType type = MediaType.parseMediaType(\u0026#34;application/json; charset=UTF-8\u0026#34;); headers.setContentType(type); HttpEntity\u0026lt;String\u0026gt; reqE = new HttpEntity\u0026lt;String\u0026gt;(json.toString(), headers); RestTemplate restTemplate = new RestTemplate(); ResponseEntity\u0026lt;Map\u0026gt; result = restTemplate.exchange(url, HttpMethod.POST, reqE, Map.class); ","date":"2017-03-04T14:53:54+08:00","permalink":"/post/2017-03-04-eureka%E7%9A%84resttemplate%E9%97%AE%E9%A2%98/","title":"Eureka 的 RestTemplate 问题"},{"content":"在执行下面这段代码时遇到问题：\nvar applseq = \u0026#34;\u0026#34;; $.ajax({ type: \u0026#34;GET\u0026#34;, url: \u0026#34;/app/appserver/ca/hdjrforward\u0026#34;, data: { \u0026#34;code\u0026#34;: code }, dataType: \u0026#34;json\u0026#34;, success: function (data) { applseq = data.body.applseq; alert(\u0026#34;1：\u0026#34;+applseq); } alert(\u0026#34;2：\u0026#34;+applseq); }); 运行结果是，先弹「2：」，接着弹「1：422133」。\n且结果是必然如是发生的。\n笔者一开始猜想这会不会是浏览器在遇到异步请求时使用了多线程的方式来处理，才导致了这样的结果。查询资料发现，JS 运行在浏览器中是单线程的。\n引用如下：\n 因为JS运行在浏览器中，是单线程的，每个window一个JS线程，既然是单线程的，在某个特定的时刻只有特定的代码能够被执行，并阻塞其它的代码。而浏览器是事件驱动的（Event driven），浏览器中很多行为是异步（Asynchronized）的，会创建事件并放入执行队列中。javascript引擎是单线程处理它的任务队列，你可以理解成就是普通函数和回调函数构成的队列。当异步事件发生时，如mouse click, a timer firing, or an XMLHttpRequest completing（鼠标点击事件发生、定时器触发事件发生、XMLHttpRequest完成回调触发等），将他们放入执行队列，等待当前代码执行完成。\n  前面已经提到浏览器是事件驱动的（Event driven），浏览器中很多行为是异步（Asynchronized）的，例如：鼠标点击事件、窗口大小拖拉事件、定时器触发事件、 XMLHttpRequest完成回调等。当一个异步事件发生的时候，它就进入事件队列。浏览器有一个内部大消息循环，Event Loop（事件循环），会轮询大的事件队列并处理事件。例如，浏览器当前正在忙于处理onclick事件，这时另外一个事件发生了（如：window onSize），这个异步事件就被放入事件队列等待处理，只有前面的处理完毕了，空闲了才会执行这个事件。setTimeout也是一样，当调用的时 候，js引擎会启动定时器timer，大约xxms以后执行xxx，当定时器时间到，就把该事件放到主事件队列等待处理（浏览器不忙的时候才会真正执行）。\n ——出自 http://www.cnblogs.com/yasmi/articles/5064588.html\n解决办法：\n在 Ajax 请求中设置非异步：\nasync: false, ","date":"2017-03-04T13:45:54+08:00","permalink":"/post/2017-03-04-ajax%E7%BB%99js%E5%85%A8%E5%B1%80%E5%8F%98%E9%87%8F%E8%B5%8B%E5%80%BC%E7%9A%84%E9%97%AE%E9%A2%98/","title":"AJAX 给 JS 全局变量赋值的问题"},{"content":"当前使用的 jQuery 版本不支持 serializeObject，因此引入该函数：\n$.prototype.serializeObject=function(){ var obj=new Object(); $.each(this.serializeArray(),function(index,param){ if(!(param.name in obj)){ obj[param.name]=param.value; } }); return obj; }; 然后序列化该表单数据，并发送 AJAX 请求：\nvar param = JSON.stringify($(\u0026#34;#applicationForm\u0026#34;).serializeObject()); $.ajax({ url: \u0026#34;/app/saveUsers\u0026#34;, data: param, type: \u0026#34;POST\u0026#34;, contentType: \u0026#34;application/json\u0026#34;, success: function(data){ if (data.head.retFlag==\u0026#34;00000\u0026#34;){ alert(\u0026#34;注册成功！\u0026#34;); window.location.href=\u0026#39;/app/ht/signContract.html\u0026#39;; return; } else { alert(data.head.retMsg); return; } }}); ","date":"2017-03-04T13:42:54+08:00","permalink":"/post/2017-03-04-ajax-post%E8%AF%B7%E6%B1%82%E6%8F%90%E4%BA%A4%E8%A1%A8%E5%8D%95%E4%BF%A1%E6%81%AF/","title":"AJAX POST请求提交表单信息"},{"content":" 为了完成搭建 MySQL 主从数据库的任务，在自己电脑上从头搭建环境。遇到的问题和解决方法在这里做一一记录。\n 问题1：  使用 VMware 安装虚拟机时，出现「not enough free space on disks」的提示。\n 解决方法：在配置虚拟机硬盘大小时，应大于等于4GB，否则就会报这个错误。\n安装 JDK 记录：  使用su root命令切换至 root 用户。 使用rpm -qa | grep java查看本机是否已安装 Java。 使用yum -y list java*查看可以下载安装的 Java 包。 使用yum -y install java-1.8.0-openjdk*安装1.8.0版本的 JDK。    问题2：  安装 JDK 时，出现「Disk Requirements: At least 821MB more space needed on the / filesystem.」的错误提示。\n 解决方法：在 VMware 上扩展磁盘后，还需在 linux 上执行硬盘空间的挂载。中间遇到较多问题难以解决，笔者对于 linux 硬盘挂载的原理也不甚了解，目前 linux 虚拟机上没有什么重要的东西，基于时间原因决定放弃，重新安装虚拟机。\n总结：安装虚拟机的时候，千万不要心疼硬盘空间，能省不少麻烦！\n Linux 网络配置记录： 网络连接设置配置文件：\n  /etc/sysconfig/network    /etc/sysconfig/network-scripts/ifcfg-eth0 /etc/sesolv.conf  # network 基础配置： NETWORKING=yes HOSTNAME=localhost.localdomain GATEWAY=192.168.129.2 # ifcfg-eth0 基础配置： DEVICE=\u0026#34;eth0\u0026#34; #BOOTPROTO=\u0026#34;dhcp\u0026#34; BOOTPROTO=\u0026#34;static\u0026#34; IPADDR=192.168.129.129 NETMASK=255.255.255.0 HWADDR=\u0026#34;00:0C:29:56:8F:AD\u0026#34; IPV6INIT=\u0026#34;no\u0026#34; NM_CONTROLLED=\u0026#34;yes\u0026#34; ONBOOT=\u0026#34;yes\u0026#34; TYPE=\u0026#34;Ethernet\u0026#34; UUID=\u0026#34;ba48a4c0-f33d-4e05-98bd-248b01691c20\u0026#34; DNS1=192.168.129.2 # resolv.conf 基础配置： nameserver 192.168.129.2 ——查阅自zhanjindong 博客\n 问题3：  在局域网中有两台 linux 虚拟机，网络连接使用的是默认的 NAT，导致两个虚拟机的 IP 地址完全相同。\n 解决方法：连接方式更换为 Bridge 桥接模式，顺利解决。\n 卸载 MySQL 记录： 由于搭建 linux 虚拟机的目的是搭建 MySQL 集群，因此需要给两个虚拟机安装同样的 MySQL。 经检查，其中一个虚拟机中已安装 MySQL，因此把它卸载了。\n rpm -qa | grep -i mysql检查机器上是否已安装 MySQL。 service mysql status检查 MySQL 运行状况。 若运行中，service mysql stop关闭 MySQL 服务。 rpm -ev MySQL-client.x86_64进行卸载（需卸载所有已安装的服务，通常有多个）。 若失败，可尝试yum remove mysql mysql-server mysql-libs mysql-server find / -name mysql系统中残留的 MySQL 相关文件 rm -rf /usr/lib64/mysql删除这些文件。 userdel mysql\u0026amp;groupdel mysql删除 MySQL 用户及用户组。 检查是否卸载干净：whereis mysql\u0026amp;more /etc/passwd | grep mysql\u0026amp;more /etc/shadow | grep mysql\u0026amp;more /etc/group | grep mysql  ——参考自[潇湘隐者博客]\n 安装 MySQL 记录：  安装5.7版本 MySQL : http://dev.mysql.com/get/Downloads/MySQL-5.7/mysql-5.7.17-1.el6.x86_64.rpm-bundle.tar （CentOS 6.5 应下载 el6 版本，CentOS 7 应下载 el7 版本）。 tar -xvf mysql-5.7.14-1.el6.x86_64.rpm-bundle.tar解压 tar 包。    rpm -ivh mysql-community-libs-5.7.14-1.el6.x86_64.rpm rpm -ivh mysql-community-client-5.7.14-1.el6.x86_64.rpm rpm -ivh mysql-community-server-5.7.14-1.el6.x86_64.rpm```\n service mysqld start启动 MySQL 服务。 vi /var/log/mysqld.log查找临时登陆密码。 **问题：**登陆后修改密码时遇到无论设什么样的密码都报ERROR 1819 (HY000): Your password does not satisfy the current policy requirements，可先在 /etc/my.cnf 配置 validate-password=off，重启服务。 修改 mysql 密码set password=`123` 。 添加远程登陆用户。  use mysql; GRANT ALL PRIVILEGES ON *.* TO 'root'@'%' IDENTIFIED BY '123' WITH GRANT OPTION;  检查用户表，刷新内存权限。  mysql\u0026gt; select host,user from user; +-----------+-----------+ | host | user | +-----------+-----------+ | % | root | | localhost | mysql.sys | | localhost | root | +-----------+-----------+ 3 rows in set (0.00 sec) mysql\u0026gt; flush privileges; Query OK, 0 rows affected (0.00 sec)  设置防火墙3306端口开启。  vim /etc/sysconfig/iptables 添加一行：\n-A INPUT -m state --state NEW -m tcp -p tcp --dport 3306 -j ACCEPT  重启防火墙。  service iptables restart  记录：配置虚拟机静态IP  关闭 NetworkManager：  $ chkconfig NetworkManager off $ service NetworkManager stop Stopping NetworkManager daemon: [ OK ]  配置网络配置文件：  $ cd /etc/sysconfig/network-scripts $ vim ifcfg-eth0  ifcfg-eth0 配置如下：  DEVICE=\u0026#34;eth0\u0026#34; #BOOTPROTO=\u0026#34;dhcp\u0026#34; BOOTPROTO=\u0026#34;static\u0026#34; IPADDR=192.168.1.111 NETMASK=255.255.255.0 HWADDR=\u0026#34;00:0C:29:01:2E:9F\u0026#34; #IPV6INIT=\u0026#34;yes\u0026#34; IPV6INIT=\u0026#34;no\u0026#34; NM_CONTROLLED=\u0026#34;yes\u0026#34; ONBOOT=\u0026#34;yes\u0026#34; TYPE=\u0026#34;Ethernet\u0026#34; UUID=\u0026#34;d15902b1-0564-4cd5-9be2-714936bbcd1f\u0026#34; DNS1=192.168.1.1 GATEWAY=192.168.1.50 #宿主机器IP BRIDGE=\u0026#34;br0\u0026#34;  ifcfg-br0 配置如下：  DEVICE=\u0026#34;br0\u0026#34; BOOTPROTO=\u0026#34;static\u0026#34; ONBOOT=\u0026#34;yes\u0026#34; IPADDR=192.168.1.111 TYPE=\u0026#34;Bridge\u0026#34; GATEWAY=192.168.1.1 DNS1=192.168.1.1  重启网络服务。  ","date":"2017-03-04T13:29:54+08:00","permalink":"/post/2017-03-04-win10%E6%90%AD%E5%BB%BAlinux%E8%99%9A%E6%8B%9F%E6%9C%BA%E5%B1%80%E5%9F%9F%E7%BD%91-%E5%AE%89%E8%A3%85mysql/","title":"win10 搭建 linux 虚拟机局域网，安装 MySQL"},{"content":"first blog\n终于把blog搭起来了，累！\n等等就把在简书的东西都挪过来！\n饿~~\n","date":"2017-03-02T23:39:54+08:00","permalink":"/post/2017-03-02-hi/","title":"Hi!!"},{"content":" 使用 MySQL 版本：5.7 系统环境：CentOS 6.5  修改主服务器（master）配置： $ vim /etc/my.cnf # 启用二进制日志 log-bin=mysql-bin # 服务器唯一ID server-id=111 修改从服务器（slave）配置： $ vim /etc/my.cnf # 启用二进制日志，可不配 log-bin=mysql-bin # 服务器唯一ID server-id=112 重启两个 MySQL 服务 service mysqld restart; 在主库建一个专用来备份的 MySQL 账户 mysql\u0026gt; grant replication slave,reload,super on *.* \u0026gt; to 'backup'@'192.168.1.50' identified by 'password'; Query OK, 0 rows affected, 1 warning (0.01 sec) mysql\u0026gt; flush privileges; Query OK, 0 rows affected (0.00 sec) backup：账号名\npassword：密码\n192.168.1.50：从库IP地址\n记录主库状态 mysql\u0026gt; show master status; +------------------+----------+--------------+------------------+-------------------+ | File | Position | Binlog_Do_DB | Binlog_Ignore_DB | Executed_Gtid_Set | +------------------+----------+--------------+------------------+-------------------+ | mysql-bin.000001 | 622 | | | | +------------------+----------+--------------+------------------+-------------------+ 1 row in set (0.00 sec) 修改从库配置 mysql\u0026gt; change master to master_host='192.168.1.111',master_user='backup', -\u0026gt; master_password='1029384756',master_log_file='mysql-bin.000001', -\u0026gt; master_log_pos=622; Query OK, 0 rows affected, 2 warnings (0.02 sec) mysql\u0026gt; start slave; Query OK, 0 rows affected (0.01 sec) 主库状态中的 File 对应 master_log_file；\n主库状态中的 Position 对应 master_log_pos。\n问题 在从库执行show slave status\\G;得出结果如下：\nmysql\u0026gt; show slave status\\G; *************************** 1. row *************************** Slave_IO_State: Connecting to master Master_Host: 192.168.1.111 Master_User: backup Master_Port: 3306 Connect_Retry: 60 Master_Log_File: mysql-bin.000001 Read_Master_Log_Pos: 622 Relay_Log_File: localhost-relay-bin.000001 Relay_Log_Pos: 4 Relay_Master_Log_File: mysql-bin.000001 Slave_IO_Running: Connecting Slave_SQL_Running: Yes Replicate_Do_DB: Replicate_Ignore_DB: Replicate_Do_Table: Replicate_Ignore_Table: Replicate_Wild_Do_Table: Replicate_Wild_Ignore_Table: Last_Errno: 0 Last_Error: Skip_Counter: 0 Exec_Master_Log_Pos: 622 Relay_Log_Space: 154 Until_Condition: None Until_Log_File: Until_Log_Pos: 0 Master_SSL_Allowed: No Master_SSL_CA_File: Master_SSL_CA_Path: Master_SSL_Cert: Master_SSL_Cipher: Master_SSL_Key: Seconds_Behind_Master: NULL Master_SSL_Verify_Server_Cert: No Last_IO_Errno: 1045 Last_IO_Error: error connecting to master 'backup@192.168.1.111:3306' - retry-time: 60 retries: 1 Last_SQL_Errno: 0 Last_SQL_Error: Replicate_Ignore_Server_Ids: Master_Server_Id: 0 Master_UUID: Master_Info_File: /var/lib/mysql/master.info SQL_Delay: 0 SQL_Remaining_Delay: NULL Slave_SQL_Running_State: Slave has read all relay log; waiting for more updates Master_Retry_Count: 86400 Master_Bind: Last_IO_Error_Timestamp: 161221 22:56:48 Last_SQL_Error_Timestamp: Master_SSL_Crl: Master_SSL_Crlpath: Retrieved_Gtid_Set: Executed_Gtid_Set: Auto_Position: 0 Replicate_Rewrite_DB: Channel_Name: Master_TLS_Version: 1 row in set (0.00 sec) 后检查发现原因是之前在主库中设置从库IP地址时设错了。\n于是去主库修改备份账户的IP地址：\nmysql\u0026gt; update user set host='192.168.1.112' where user='backup'; Query OK, 1 row affected (0.00 sec) Rows matched: 1 Changed: 1 Warnings: 0 mysql\u0026gt; flush privileges; Query OK, 0 rows affected (0.01 sec) 再次查询从库状态：\n*************************** 1. row *************************** Slave_IO_State: Waiting for master to send event Master_Host: 192.168.1.111 Master_User: backup Master_Port: 3306 Connect_Retry: 60 Master_Log_File: mysql-bin.000001 Read_Master_Log_Pos: 1508 Relay_Log_File: localhost-relay-bin.000002 Relay_Log_Pos: 320 Relay_Master_Log_File: mysql-bin.000001 Slave_IO_Running: Yes Slave_SQL_Running: No Replicate_Do_DB: Replicate_Ignore_DB: Replicate_Do_Table: Replicate_Ignore_Table: Replicate_Wild_Do_Table: Replicate_Wild_Ignore_Table: Last_Errno: 1032 Last_Error: Could not execute Update_rows event on table mysql.user; Can't find record in 'user', Error_code: 1032; handler error HA_ERR_KEY_NOT_FOUND; the event's master log mysql-bin.000001, end_log_pos 1277 Skip_Counter: 0 Exec_Master_Log_Pos: 622 Relay_Log_Space: 1417 Until_Condition: None Until_Log_File: Until_Log_Pos: 0 Master_SSL_Allowed: No Master_SSL_CA_File: Master_SSL_CA_Path: Master_SSL_Cert: Master_SSL_Cipher: Master_SSL_Key: Seconds_Behind_Master: NULL Master_SSL_Verify_Server_Cert: No Last_IO_Errno: 0 Last_IO_Error: Last_SQL_Errno: 1032 Last_SQL_Error: Could not execute Update_rows event on table mysql.user; Can't find record in 'user', Error_code: 1032; handler error HA_ERR_KEY_NOT_FOUND; the event's master log mysql-bin.000001, end_log_pos 1277 Replicate_Ignore_Server_Ids: Master_Server_Id: 111 Master_UUID: 37503273-c521-11e6-90f8-000c29012e9f Master_Info_File: /var/lib/mysql/master.info SQL_Delay: 0 SQL_Remaining_Delay: NULL Slave_SQL_Running_State: Master_Retry_Count: 86400 Master_Bind: Last_IO_Error_Timestamp: Last_SQL_Error_Timestamp: 161221 23:00:48 Master_SSL_Crl: Master_SSL_Crlpath: Retrieved_Gtid_Set: Executed_Gtid_Set: Auto_Position: 0 Replicate_Rewrite_DB: Channel_Name: Master_TLS_Version: 初步判断问题是由于之前在主库执行的 update 语句，导致主从库数据不一致，使得数据无法同步。\n因此在从库中执行了同样的 update 语句，依然报错。\n分析可能是由于 update 语句的执行，主库的日志偏移点发生了变化，使得从库无法同步数据。因此笔者做了如下操作：\n# 主库： mysql\u0026gt; show master status; +------------------+----------+--------------+------------------+-------------------+ | File | Position | Binlog_Do_DB | Binlog_Ignore_DB | Executed_Gtid_Set | +------------------+----------+--------------+------------------+-------------------+ | mysql-bin.000001 | 1508 | | | | +------------------+----------+--------------+------------------+-------------------+ 1 row in set (0.00 sec) # 从库： mysql\u0026gt; stop slave IO_THREAD; Query OK, 0 rows affected (0.00 sec) mysql\u0026gt; change master to master_host='192.168.1.111',master_user='backup', -\u0026gt; master_password='123',master_log_file='mysql-bin.000001', master_log_pos=1508; Query OK, 0 rows affected, 2 warnings (0.01 sec) mysql\u0026gt; start slave io_thread; Query OK, 0 rows affected (0.01 sec) # 重启从库的 MySQL 服务 $ service mysqld restart 然后查询从库状态：\n*************************** 1. row *************************** Slave_IO_State: Waiting for master to send event Master_Host: 192.168.1.111 Master_User: backup Master_Port: 3306 Connect_Retry: 60 Master_Log_File: mysql-bin.000001 Read_Master_Log_Pos: 1508 Relay_Log_File: localhost-relay-bin.000004 Relay_Log_Pos: 320 Relay_Master_Log_File: mysql-bin.000001 Slave_IO_Running: Yes Slave_SQL_Running: Yes Replicate_Do_DB: Replicate_Ignore_DB: Replicate_Do_Table: Replicate_Ignore_Table: Replicate_Wild_Do_Table: Replicate_Wild_Ignore_Table: Last_Errno: 0 Last_Error: Skip_Counter: 0 Exec_Master_Log_Pos: 1508 Relay_Log_Space: 531 Until_Condition: None Until_Log_File: Until_Log_Pos: 0 Master_SSL_Allowed: No Master_SSL_CA_File: Master_SSL_CA_Path: Master_SSL_Cert: Master_SSL_Cipher: Master_SSL_Key: Seconds_Behind_Master: 0 Master_SSL_Verify_Server_Cert: No Last_IO_Errno: 0 Last_IO_Error: Last_SQL_Errno: 0 Last_SQL_Error: Replicate_Ignore_Server_Ids: Master_Server_Id: 111 Master_UUID: 37503273-c521-11e6-90f8-000c29012e9f Master_Info_File: /var/lib/mysql/master.info SQL_Delay: 0 SQL_Remaining_Delay: NULL Slave_SQL_Running_State: Slave has read all relay log; waiting for more updates Master_Retry_Count: 86400 Master_Bind: Last_IO_Error_Timestamp: Last_SQL_Error_Timestamp: Master_SSL_Crl: Master_SSL_Crlpath: Retrieved_Gtid_Set: Executed_Gtid_Set: Auto_Position: 0 Replicate_Rewrite_DB: Channel_Name: Master_TLS_Version: Slave_IO_Running: Yes\nSlave_SQL_Running: Yes\n成功！\n测试一下效果：\n# 在主库新增一个 database mysql\u0026gt; create database mytest1221; Query OK, 1 row affected (0.02 sec) # 在从库查询 database mysql\u0026gt; show databases; +--------------------+ | Database | +--------------------+ | information_schema | | mysql | | mytest1221 | | performance_schema | | sys | +--------------------+ 5 rows in set (0.00 sec)  public static void main(String[] args) { System.out.println(\u0026#34;hello world\u0026#34;); } ","date":"2017-01-02T23:39:54+08:00","image":"/3953273590_704e3899d5_m.jpg","permalink":"/post/2017-01-02-mysql%E6%90%AD%E5%BB%BA%E4%B8%BB%E4%BB%8E%E6%95%B0%E6%8D%AE%E5%BA%93/","title":"MySQL 搭建主从数据库"},{"content":"Hugo ships with several Built-in Shortcodes for rich content, along with a Privacy Config and a set of Simple Shortcodes that enable static and no-JS versions of various social media embeds.\n YouTube Privacy Enhanced Shortcode    bilibilibi Shortcode:q \r","date":"2015-03-10T00:00:00Z","permalink":"/post/rich-content/","title":"Rich Content"},{"content":"java中重要的函数接口    接口 参数 返回类型 示例     Predicate\u0026lt; T \u0026gt; T boolean 这张唱片已经发行了吗   Consumer\u0026lt; T \u0026gt; T void 输出一个值   Function\u0026lt; T,R \u0026gt; T R 获得Artist对象的名字   Supplier\u0026lt; T \u0026gt; None T 工厂方法   UnaryOperator\u0026lt; T \u0026gt; T T 逻辑非   BinaryOperator\u0026lt; T \u0026gt; (T,T) T 求两个数的乘积    stream 中的 filter 方法和 count 方法 filter 方法并未做什么实际性的工作，只刻画出了stream，但没有产生新的集合，这类方法叫惰性求值；\ncount 方法最终会从 stream 产生值，这类方法叫及早求值方法。\nStream.of()和*.stream()的区别 Stream.of(T t\u0026hellip;)中t是流的多个元素，.stream()是把集合的每个元素变成流\nStream\u0026lt;List\u0026lt;Track\u0026gt;\u0026gt; stream = Stream.of(tracks); Stream\u0026lt;Track\u0026gt; stream2 = tracks.stream();  map\n元素处理，一一映射  List\u0026lt;Integer\u0026gt; collect1 = allInt.stream().filter(ele -\u0026gt; ele \u0026gt; 5) .map(ele -\u0026gt; ele * 10).collect(Collectors.toList()); System.out.println(collect1);  filter\n过滤元素 flatMap\n可以把多个流合并成一个流 返回值是stream  List\u0026lt;Integer\u0026gt; collect = Stream.of(list1, list2).flatMap(ele -\u0026gt; ele.stream()) .collect(Collectors.toList()); System.out.println(collect);  min() \u0026amp; max()\n比较  List\u0026lt;Track\u0026gt; tracks = Arrays.asList(new Track(\u0026#34;imagine\u0026#34;, 92),new Track (\u0026#34;super star\u0026#34;, 28), new Track(\u0026#34;halo\u0026#34;, 64)); Track track1 = tracks.stream().min(Comparator.comparing(track -\u0026gt; track.getName().length())).get();  reduce\n循环计算\nreduce(初始值, BinaryOperator\u0026lt;T\u0026gt;(传递的循环计算结果, 遍历的流中的值))  Integer reduce = Stream.of(1, 2, 3).reduce(10, (acc, element) -\u0026gt; acc - element);  range  IntStream.range(0, 5).forEach(num -\u0026gt; System.out.print(num + \u0026#34; \u0026#34;)); // 输出 0，1，2，3，4，5   skip\n跳过前 n 个元素\n  limit\n截取至第 n 个元素\n  拆装箱 int =\u0026gt; Integer : intFunction\nInteger =\u0026gt; int : toIntFunction\n高阶函数使用基本类型：mapToInt()——方法 + to + 基本类型\nmapToInt 返回的不是一个一般的 stream，这个 stream 的 map() 等方法都用的不是原来的接口。\n该特殊 stream 有个 summaryStatistics() 方法得到的对象中有诸多计算属性，方便计算。\nIntSummaryStatistics iss = album.getTracks().stream() .mapToInt(trac -\u0026gt; trac.getLength()) .map(length -\u0026gt; length + 1) .summaryStatistics(); System.out.println(iss); // 输出 IntSummaryStatistics{count=1, sum=11, min=11, average=11.000000, max=11} 重载 会优先使用最具体的类型的函数\n错误： Ambiguous method call .Both\n重载函数模糊调用，参数列表都匹配。\n 只有一个可能的目标类型：由相应函数接口里的参数类型推导得出； 多个可能的目标类型：由最具体的参数类型推导得出； 多个可能的目标且具体类型不明：需人为指定类型，否则编译报错。  默认方法 接口（无论函数还是非函数）告诉它的所有子类：如果你没有实现这个方法，就使用我的吧。 子类重写方法覆盖默认方法。\n如果一个类实现了两个含有相同签名函数的接口，编译报错。解决方法：实现类实现该函数。\n 类胜于接口 子类胜于父类\n接口：允许多重继承，没有成员变量；\n抽象类：不能多重继承，可继承成员变量。  Optional String s = null; Optional\u0026lt;String\u0026gt; optional = Optional.ofNullable(s); s = \u0026#34;aa\u0026#34;; 在上面这段代码中，最后一行赋值并没有任何作用：Optional对象直接被赋予了String的值，而非String对象\nOptional对空值更简单的处理：\nOptional\u0026lt;String\u0026gt; op = Optional.ofNullable(str); String result = op.orElseGet(() -\u0026gt; \u0026#34;\u0026#34;); //相当于： String result = str==null ? \u0026#34;\u0026#34; : str; orElse 和 orElseGet 的区别 optional.orElse(\u0026#34;unknow\u0026#34;); optional.orElseGet(() -\u0026gt; \u0026#34;unknow\u0026#34;); 流的顺序 原集合有序，则出去的流依然有序；原集合无序，则出去的流也无序。\n一些操作在有序的流上开销更大，可调用unordered方法消除顺序；大多数操作（filter map reduce）在有序流上效率更高。\nCollect stream类库在collect的时候自动挑选合适的集合类型。\n如果需要指定类型，则可以：\nstream.collect(Collectors.toCollection(TreeSet::new)); 转换成值 // 找出成员最多的乐队 Function\u0026lt;Artist, Long\u0026gt; getCount = artist -\u0026gt; artist.getMembers.count(); Optional\u0026lt;Artist\u0026gt; maxArtist = artists.stream(). collect(Collectors.maxBy( Comparator.comparing(getCount))); // 一组乐队的成员平均数 Double averageMember = artists.stream().collect( Collectors.averagingInt( artist -\u0026gt; artist.getMembers().size())); partitioningBy收集器 // 区分乐队和单个歌手 Map\u0026lt;Boolean,List\u0026lt;Artist\u0026gt;\u0026gt; map = stream.collect(Collectors.partitioningBy (artist -\u0026gt; artist.isSolo())); // 另一种写法：使用方法 Map\u0026lt;Boolean, List\u0026lt;Artist\u0026gt;\u0026gt; map = stream.collect( Collectors.partitioningBy(Artist:: isSolo)); 拼接字符串 把流中的元素按照规律拼接成字符串。 joining(元素中分隔字符，开始字符，结束字符)\nString collect = f4.getMembers().stream() .map(Artist:: getName) .collect(Collectors.joining(\u0026#34;,\u0026#34;,\u0026#34;[\u0026#34;,\u0026#34;]\u0026#34;)); 组合收集器 把流中的元素按照规则分组，并与想收集的值关联。 groupingBy(分组的方式Function, 收集的数据Collector)\n// 计算每个艺术家的专辑数 Map\u0026lt;Artist, Long\u0026gt; map = albums.stream().collect( Collectors.groupingBy(Album:: getMainArtist, Collectors.counting())); // 每个艺术家的专辑名 Map\u0026lt;Artist, List\u0026lt;String\u0026gt;\u0026gt; map = albums.stream().collect( Collectors.groupingBy(Album:: getMainArtist, Collectors.mapping(Album:: getName, Collectors.toList()))); map的遍历 Map\u0026lt;Artist, Integer\u0026gt; countOfAlbums = new HashMap\u0026lt;\u0026gt;(); albumMap.forEach((artist, albumList) -\u0026gt; countOfAlbums.put(artist, albumList.size())); 并行化 lambda 并行化示例：\n// 计算专辑曲目总长度 albumList.parallelStream().flatMap(Album:: getTracks).mapToInt(Track:: getLength).sum(); 影响并行流性能的主要因素：\n 数据大小\n数据足够大、每个数据处理管道花费的时间足够多时适用并行； 源数据结构\n不同的数据源分割相对容易； 装箱\n基本类型快于装箱类型； 核的数量\n空闲核越多，越适合并行； 单元处理开销\n花在流中每个元素身上的时间越长，越适合并行操作。  分割性能好坏：\n 性能好\nArrayList、数组、IntStream.range。\n支持随机读取，能轻而易举地被分解。 性能一般\nHashSet、TreeSet。\n不易被公平地分解。 性能差\nLinkedList、Streams.iterate、BufferedReader.lines……\n长度未知，很难预测该在哪里分解。  无状态操作比有状态操作并行性能更佳。\n无状态操作：map、filter、flatMap\n有状态操作：sorted、distinct、limit\n数组并行化 在工具类 Arrays 中\nparallelPrefix : 任意给定一个 BinaryOperator 函数，计算两个值的结果\nparallelSetAll : 使用 Lambda 表达式更新数组元素\nparallelSort : 并行化对数组元素排序\nint[] intArray = new int[100]; Arrays.parallelSetAll(intArray, index -\u0026gt; intArray[index] = index + 1); 求滑动窗口平均数：\n我的做法：\ndouble[] mySum = Arrays.copyOf(values, values.length); double[] myAverage = IntStream.range(0, values.length - movingLength + 1).mapToDouble(i -\u0026gt; { return Arrays.stream(mySum).skip(i).limit(movingLength).sum() / movingLength; }).toArray(); 使用 parallelPrefix 来做：\ndouble[] sums = Arrays.copyOf(values, values.length); // 求得各角标的累计和 Arrays.parallelPrefix(sums, Double:: sum); int start = movingLength - 1; double[] average = IntStream.range(start, sums.length).mapToDouble(i -\u0026gt; { double prefix = i == start ? 0 : sums[i - movingLength]; return (sums[i] - prefix) / movingLength; }).toArray(); 代码重构 ThreadLocal 的优化 重构前：\nThreadLocal\u0026lt;String\u0026gt; threadLocal = new ThreadLocal(){ @override protected String initialValue() { return getChannelNo(); } }; 重构后：\nThreadLocal\u0026lt;String\u0026gt; threadLocal = ThreadLocal.withInitial(() -\u0026gt; getChannelNo()); 重复代码的优化 重构前：\npublic long countRunningTime() { return albums.stream().mapToLong(album -\u0026gt; album.getTracks() .mapToLong(track -\u0026gt; track.getLength()).sum()).sum(); } public long countMusicians() { return albums.stream().mapToLong(album -\u0026gt; album.getMusicians().count()).sum(); } 重构后：\npublic long countFeature(ToLongFunction\u0026lt;Album\u0026gt; function) { return albums.stream().mapToLong(function).sum(); } public long countTracks() { return countFeature(album -\u0026gt; album.getTracks().count()); } public long countMusicians() { return countFeature(album -\u0026gt; album.getMusicians().count()); } peek 记录中间值 peek 方法可以用来记录流中的值以便对程序进行调试。\nSet\u0026lt;String\u0026gt; nations = album.getMusicians().map(artist -\u0026gt; artist.getNationality()) .peek(nation -\u0026gt; logger.debug(nation)).collect(Collectors.toSet()); 如果有在 lambda 表达式中打断点的需要，可以定义一个空的方法放在peek中，给这个空方法打断点。\n几个 lambda 表达式的最佳实践  对流中的 pojo 元素的排序  List\u0026lt;Person\u0026gt; persons = new ArrayList\u0026lt;\u0026gt;(); persons.sort((p1, p2) -\u0026gt; p1.getAge().compareTo(p2.getName())); ","date":"0001-01-01T00:00:00Z","permalink":"/post/2017-03-04-java8-%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0lambda/","title":"Java 1.8 学习笔记——Lambda"}]